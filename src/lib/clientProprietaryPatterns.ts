/**
 * Client-compatible proprietary patterns for code cleaning
 * Centralized patterns used by zipAnalyzer and SimpleLiberationFlow
 * This is a client-side version of supabase/functions/_shared/proprietary-patterns.ts
 * 
 * ENHANCED: Version 3.0 - MAXIMUM SOVEREIGNTY with exhaustive patterns
 */

// ============= PROPRIETARY PATTERNS TO DETECT =============

export const PROPRIETARY_IMPORTS: RegExp[] = [
  // Lovable / GPT Engineer patterns
  /@lovable\//g,
  /@gptengineer\//g,
  /from ['"]lovable/g,
  /from ['"]gptengineer/g,
  /from ['"]@lovable/g,
  /from ['"]@gptengineer/g,
  /lovable-tagger/g,
  /componentTagger/g,
  /lovable-core/g,
  /gpt-engineer/g,
  
  // Bolt patterns
  /@bolt\//g,
  /from ['"]bolt/g,
  /from ['"]@bolt/g,
  
  // v0 (Vercel) patterns
  /@v0\//g,
  /from ['"]v0/g,
  /from ['"]@v0/g,
  /v0-tagger/g,
  /v0-runtime/g,
  
  // Cursor patterns
  /@cursor\//g,
  /from ['"]cursor/g,
  /from ['"]@cursor/g,
  /cursor-sdk/g,
  
  // Replit patterns
  /@replit\//g,
  /from ['"]replit/g,
  /replit-runtime/g,
  
  // ============= NEW AI PLATFORMS =============
  
  // Windsurf / Codeium patterns
  /@codeium\//g,
  /from ['"]codeium/g,
  /from ['"]@codeium/g,
  /from ['"]windsurf/g,
  /@windsurf\//g,
  /codeium-/g,
  /windsurf-/g,
  
  // GitHub Copilot patterns
  /@github\/copilot/g,
  /from ['"]@github\/copilot/g,
  /copilot-/g,
  /@copilot\//g,
  
  // Tabnine patterns
  /@tabnine\//g,
  /from ['"]tabnine/g,
  /from ['"]@tabnine/g,
  /tabnine-/g,
  
  // Aider patterns
  /from ['"]aider/g,
  /aider-chat/g,
  /@aider\//g,
  
  // Cline patterns
  /@cline\//g,
  /from ['"]@cline/g,
  /from ['"]cline/g,
  /cline-/g,
  
  // Amazon Q / CodeWhisperer patterns
  /@aws\/codewhisperer/g,
  /from ['"]@aws\/codewhisperer/g,
  /@amazon-q\//g,
  /from ['"]@amazon-q/g,
  /amazon-q-/g,
  /codewhisperer-/g,
  
  // Devin patterns
  /@devin\//g,
  /from ['"]devin/g,
  /from ['"]@cognition/g,
  /@cognition\//g,
  
  // Sourcegraph Cody patterns
  /@sourcegraph\/cody/g,
  /from ['"]@sourcegraph\/cody/g,
  /@cody\//g,
  /cody-agent/g,
  
  // JetBrains AI patterns
  /@jetbrains\/ai/g,
  /from ['"]@jetbrains/g,
  /jetbrains-ai-/g,
  
  // Continue.dev patterns
  /@continue\//g,
  /from ['"]continue/g,
  /continue-/g,
  
  // === EXHAUSTIVE: Supabase integrations path (auto-generated by Lovable) ===
  /@\/integrations\/supabase/g,
  /from ['"]@\/integrations\/supabase/g,
  /from ['"]\.\.\/integrations\/supabase/g,
  /from ['"]\.\.\/\.\.\/integrations\/supabase/g,
  /from ['"]\.\.\/\.\.\/\.\.\/integrations\/supabase/g,
  /integrations\/supabase\/client/g,
  /integrations\/supabase\/types/g,
  
  // === NEW: Relative imports to integrations ===
  /from ['"]\.+\/integrations\//g,
  
  // === NEW: Any lovable-specific hook imports ===
  /@\/hooks\/use-mobile/g,
  /@\/hooks\/use-toast/g,
  /@\/hooks\/useMobile/g,
  /@\/hooks\/useToast/g,
  /from ['"]@\/hooks\/use-/g,
];

export const PROPRIETARY_FILES: string[] = [
  // Lovable / GPT Engineer
  '.bolt',
  '.lovable',
  '.gptengineer',
  '.gpteng',
  'lovable.config',
  'gptengineer.config',
  '.lovable.json',
  '.gptengineer.json',
  'bolt.config',
  '.bolt.json',
  
  // v0 (Vercel)
  '.v0',
  'v0.config',
  '.v0.json',
  'v0-manifest.json',
  
  // Cursor
  '.cursor',
  '.cursorrc',
  'cursor.config',
  '.cursor.json',
  
  // Replit
  '.replit',
  'replit.nix',
  '.replit.json',
  
  // ============= NEW AI PLATFORMS FILES =============
  
  // Windsurf / Codeium
  '.windsurf',
  '.windsurf-rules',
  'windsurf.json',
  'mcp.json',
  '.codeium',
  'codeium.json',
  '.codeiumrc',
  
  // GitHub Copilot
  '.copilot',
  'copilot-instructions.md',
  '.github/copilot',
  '.copilot.yaml',
  '.copilot.yml',
  
  // Tabnine
  '.tabnine',
  'tabnine.toml',
  '.tabnine_config',
  '.tabnine.json',
  
  // Aider
  '.aider.conf.yml',
  '.aider',
  '.aider.input.history',
  '.aider.chat.history.md',
  'CONVENTIONS.md',
  
  // Cline
  '.clinerules',
  'clinerules-bank',
  '.cline',
  '.clinesettings',
  
  // Amazon Q / CodeWhisperer
  '.amazonq',
  '.amazon-q',
  '.codewhisperer',
  'amazonq.json',
  
  // Devin
  '.devin',
  'devin.json',
  '.cognition',
  
  // Sourcegraph Cody
  '.cody',
  'cody.json',
  '.sourcegraph',
  
  // JetBrains AI
  '.idea/aiAssistant',
  '.idea/aiAssistant.xml',
  'jetbrains-ai.json',
  
  // Continue.dev
  '.continue',
  '.continuerc.json',
  
  // === EXHAUSTIVE: Auto-generated Supabase files ===
  'src/integrations/supabase/types.ts',
  'src/integrations/supabase/client.ts',
  'types.ts',
  
  // === NEW: Config files that expose project IDs ===
  'supabase/.temp/',
];

// === EXHAUSTIVE: Paths to completely remove ===
export const PROPRIETARY_PATHS: string[] = [
  'src/integrations/supabase/',
  'src/integrations/',
  '.lovable/',
  '.gptengineer/',
  '.bolt/',
  '.cursor/',
  '.replit/',
  '.v0/',
  'supabase/config.toml',
  'supabase/.temp/',
  '.git/hooks/pre-push',
  
  // ============= NEW AI PLATFORMS PATHS =============
  '.windsurf/',
  '.codeium/',
  '.github/copilot/',
  '.tabnine/',
  '.aider/',
  '.clinerules/',
  'clinerules-bank/',
  '.cline/',
  '.amazonq/',
  '.amazon-q/',
  '.codewhisperer/',
  '.devin/',
  '.cognition/',
  '.cody/',
  '.sourcegraph/',
  '.idea/aiAssistant/',
  '.continue/',
];

// === NEW: Supabase project ID patterns ===
export const SUPABASE_PROJECT_PATTERNS: RegExp[] = [
  // Generic Supabase project ID format (20 lowercase letters)
  /[a-z]{20}\.supabase\.co/g,
  // Specific known project patterns
  /izqveyvcebolrqpqlmho/g,
  // JWT tokens (anon keys, service role keys)
  /eyJ[A-Za-z0-9_-]{100,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g,
];

// === NEW: Exposed API keys patterns ===
export const EXPOSED_KEYS_PATTERNS: RegExp[] = [
  // Stripe live keys
  /sk_live_[A-Za-z0-9]{20,}/g,
  /pk_live_[A-Za-z0-9]{20,}/g,
  // Stripe test keys (also should be cleaned for sovereignty)
  /sk_test_[A-Za-z0-9]{20,}/g,
  /pk_test_[A-Za-z0-9]{20,}/g,
  // Generic API key patterns
  /api[_-]?key['":\s]+['"][A-Za-z0-9_-]{20,}['"]/gi,
  /secret[_-]?key['":\s]+['"][A-Za-z0-9_-]{20,}['"]/gi,
];

export const PROPRIETARY_CONTENT: RegExp[] = [
  // Import statements
  /import\s*{\s*componentTagger\s*}\s*from\s*['"]lovable-tagger['"]\s*;?\n?/g,
  /import\s*.*\s*from\s*['"]@lovable\/[^'"]*['"]\s*;?\n?/g,
  /import\s*.*\s*from\s*['"]@gptengineer\/[^'"]*['"]\s*;?\n?/g,
  /import\s*.*\s*from\s*['"]lovable-[^'"]*['"]\s*;?\n?/g,
  /import\s*.*\s*from\s*['"]@v0\/[^'"]*['"]\s*;?\n?/g,
  /import\s*.*\s*from\s*['"]@bolt\/[^'"]*['"]\s*;?\n?/g,
  /import\s*.*\s*from\s*['"]@cursor\/[^'"]*['"]\s*;?\n?/g,
  
  // === EXHAUSTIVE: Supabase auto-generated imports ===
  /import\s*{\s*supabase\s*}\s*from\s*['"]@\/integrations\/supabase\/client['"]\s*;?\n?/g,
  /import\s*.*\s*from\s*['"]@\/integrations\/supabase\/[^'"]*['"]\s*;?\n?/g,
  /import\s+type\s*{\s*[^}]*\s*}\s*from\s*['"]@\/integrations\/supabase\/types['"]\s*;?\n?/g,
  /import\s*{\s*[^}]+\s*}\s*from\s*['"]@\/integrations\/supabase\/types['"]\s*;?\n?/g,
  
  // Plugin usage in vite.config
  /mode\s*===\s*['"]development['"]\s*&&\s*componentTagger\(\)\s*,?\n?/g,
  /componentTagger\(\)\s*,?\n?/g,
  
  // Comment markers
  /\/\/\s*@lovable.*\n?/g,
  /\/\*\s*@lovable[\s\S]*?\*\//g,
  /\/\/\s*@gptengineer.*\n?/g,
  /\/\*\s*@gptengineer[\s\S]*?\*\//g,
  /\/\/\s*@bolt.*\n?/g,
  /\/\*\s*@bolt[\s\S]*?\*\//g,
  /\/\/\s*@v0.*\n?/g,
  /\/\*\s*@v0[\s\S]*?\*\//g,
  /\/\/\s*Generated by Lovable.*\n?/gi,
  /\/\/\s*Auto-generated.*lovable.*\n?/gi,
  
  // Data attributes
  /data-lovable[^"]*="[^"]*"/g,
  /data-gpt[^"]*="[^"]*"/g,
  /data-bolt[^"]*="[^"]*"/g,
  /data-lov-id="[^"]*"/g,
  /data-lov-component="[^"]*"/g,
  /data-v0[^"]*="[^"]*"/g,
  /data-codeium[^"]*="[^"]*"/g,
  /data-copilot[^"]*="[^"]*"/g,
  /data-tabnine[^"]*="[^"]*"/g,
  /data-cline[^"]*="[^"]*"/g,
  /data-cody[^"]*="[^"]*"/g,
  /data-continue[^"]*="[^"]*"/g,
  
  // Environment variable references
  /VITE_LOVABLE_[A-Z_]+/g,
  /VITE_GPT_[A-Z_]+/g,
  /VITE_CODEIUM_[A-Z_]+/g,
  /VITE_COPILOT_[A-Z_]+/g,
  /VITE_TABNINE_[A-Z_]+/g,
  /VITE_CODY_[A-Z_]+/g,
  
  // ============= GENERIC AI GENERATION COMMENTS =============
  /\/\/\s*@codeium[^\n]*\n?/gi,
  /\/\/\s*@copilot[^\n]*\n?/gi,
  /\/\/\s*@tabnine[^\n]*\n?/gi,
  /\/\/\s*@aider[^\n]*\n?/gi,
  /\/\/\s*@cline[^\n]*\n?/gi,
  /\/\/\s*@amazon-q[^\n]*\n?/gi,
  /\/\/\s*@cody[^\n]*\n?/gi,
  /\/\/\s*@continue[^\n]*\n?/gi,
  /\/\/\s*@devin[^\n]*\n?/gi,
  /\/\/\s*@jetbrains-ai[^\n]*\n?/gi,
  /\/\/\s*Generated by Copilot[^\n]*\n?/gi,
  /\/\/\s*Generated by Codeium[^\n]*\n?/gi,
  /\/\/\s*Generated by Tabnine[^\n]*\n?/gi,
  /\/\/\s*Generated by Cody[^\n]*\n?/gi,
  /\/\/\s*Generated by Continue[^\n]*\n?/gi,
  /\/\/\s*Generated by Devin[^\n]*\n?/gi,
  /\/\/\s*Generated by Amazon Q[^\n]*\n?/gi,
  /\/\/\s*AI-generated[^\n]*\n?/gi,
  /\/\/\s*AI-assisted[^\n]*\n?/gi,
  /\/\/\s*Auto-generated by [A-Za-z]+[^\n]*\n?/gi,
  /\/\*[\s\S]*?AI generated[\s\S]*?\*\//gi,
  /\/\*[\s\S]*?Generated by AI[\s\S]*?\*\//gi,
  
  // === NEW: Hidden telemetry calls ===
  /fetch\s*\(\s*['"][^'"]*lovable[^'"]*['"]/gi,
  /fetch\s*\(\s*['"][^'"]*gptengineer[^'"]*['"]/gi,
  /navigator\.sendBeacon\s*\([^)]*lovable[^)]*\)/gi,
  /navigator\.sendBeacon\s*\([^)]*gptengineer[^)]*\)/gi,
  /new\s+Image\s*\(\s*\)\s*\.src\s*=\s*['"][^'"]*lovable[^'"]*['"]/gi,
  
  // === NEW: WebSocket connections to proprietary servers ===
  /new\s+WebSocket\s*\([^)]*lovable[^)]*\)/gi,
  /new\s+WebSocket\s*\([^)]*gptengineer[^)]*\)/gi,
  /new\s+WebSocket\s*\([^)]*\.supabase\.co[^)]*\)/gi,
  
  // === NEW: Realtime channel subscriptions ===
  /supabase\.channel\s*\(/g,
  /supabase\.removeChannel\s*\(/g,
  /\.on\s*\(\s*['"]postgres_changes['"]/g,
  
  // === NEW: Service worker registrations ===
  /navigator\.serviceWorker\.register\s*\([^)]*lovable[^)]*\)/gi,
];

// === EXHAUSTIVE: Supabase-specific patterns to clean ===
export const SUPABASE_PATTERNS: RegExp[] = [
  // Direct supabase client usage that needs replacement
  /supabase\.from\s*\(/g,
  /supabase\.auth\./g,
  /supabase\.storage\./g,
  /supabase\.functions\.invoke/g,
  /supabase\.rpc\s*\(/g,
  /supabase\.channel\s*\(/g,
  /supabase\.removeChannel/g,
];

// Telemetry DOMAINS (not packages)
export const TELEMETRY_DOMAINS: string[] = [
  // Lovable / GPT Engineer
  'lovable.app',
  'lovable.dev',
  'events.lovable',
  'telemetry.lovable',
  'gptengineer.app',
  'analytics.lovable',
  'tracking.lovable',
  'api.lovable.dev',
  'ws.lovable.dev',
  'cdn.lovable.dev',
  'cdn.gptengineer.app',
  'assets.lovable',
  'static.lovable',
  'edge.lovable',
  'functions.lovable',
  
  // v0 (Vercel)
  'v0.dev',
  'telemetry.v0.dev',
  'api.v0.dev',
  'cdn.v0.dev',
  
  // Bolt
  'bolt.new',
  'api.bolt.new',
  'cdn.bolt.new',
  
  // Cursor
  'cursor.sh',
  'api.cursor.sh',
  'cursor-telemetry.dev',
  
  // Replit
  'replit.com',
  'api.replit.com',
  'telemetry.replit.com',
  
  // ============= NEW AI PLATFORMS TELEMETRY =============
  
  // Windsurf / Codeium
  'codeium.com',
  'windsurf.ai',
  'api.codeium.com',
  'telemetry.codeium.com',
  'exo.codeium.com',
  'server.codeium.com',
  
  // GitHub Copilot
  'copilot.github.com',
  'githubcopilot.com',
  'api.githubcopilot.com',
  'copilot-telemetry.github.com',
  'default.exp-tas.com',
  'copilot-proxy.githubusercontent.com',
  
  // Tabnine
  'tabnine.com',
  'api.tabnine.com',
  'hub.tabnine.com',
  'update.tabnine.com',
  'telemetry.tabnine.com',
  
  // Aider
  'aider.chat',
  'api.aider.chat',
  
  // Amazon Q / CodeWhisperer
  'codewhisperer.aws.dev',
  'codewhisperer.amazonaws.com',
  'amazon-q.aws',
  'amazonq.aws.dev',
  'q.console.aws.amazon.com',
  
  // Devin
  'devin.ai',
  'cognition.ai',
  'api.cognition.ai',
  'cognition-labs.com',
  
  // Sourcegraph Cody
  'sourcegraph.com',
  'cody.dev',
  'api.cody.dev',
  'telemetry.sourcegraph.com',
  
  // JetBrains AI
  'ai.jetbrains.com',
  'datalore.jetbrains.com',
  'jb.gg',
  
  // Continue.dev
  'continue.dev',
  'api.continue.dev',
  'proxy.continue.dev',
];

// NPM packages to remove
export const SUSPICIOUS_PACKAGES: string[] = [
  // Lovable / GPT Engineer
  'lovable-tagger',
  '@lovable/core',
  '@lovable/cli',
  '@lovable/runtime',
  '@lovable/plugin-react',
  '@gptengineer/core',
  '@gptengineer/cli',
  'gpt-engineer',
  'lovable-analytics',
  'gpt-engineer-tracker',
  
  // Bolt
  'bolt-core',
  '@bolt/core',
  '@bolt/cli',
  '@bolt/runtime',
  
  // v0 (Vercel)
  '@v0/core',
  '@v0/cli',
  '@v0/runtime',
  '@v0/ui',
  'v0-tagger',
  'v0-sdk',
  
  // Cursor
  '@cursor/core',
  '@cursor/sdk',
  'cursor-runtime',
  
  // Replit
  '@replit/core',
  '@replit/extensions',
  'replit-sdk',
  
  // ============= NEW AI PLATFORMS PACKAGES =============
  
  // Windsurf / Codeium
  'codeium',
  '@codeium/core',
  '@codeium/react',
  '@codeium/sdk',
  'windsurf.nvim',
  'windsurf.vim',
  'windsurf-sdk',
  
  // GitHub Copilot
  '@github/copilot',
  'copilot.lua',
  'copilot.vim',
  'copilot-node-server',
  '@copilot/sdk',
  
  // Tabnine
  'tabnine-vscode',
  '@tabnine/core',
  '@tabnine/unity',
  'tabnine-vim',
  'tabnine-nvim',
  
  // Aider
  'aider-chat',
  'aider',
  '@aider/sdk',
  
  // Cline
  '@cline/core',
  '@cline/sdk',
  'cline-ai',
  'cline-vscode',
  
  // Amazon Q / CodeWhisperer
  '@aws/codewhisperer',
  '@aws/amazon-q',
  '@amzn/codewhisperer-streaming',
  'amazon-q-developer',
  
  // Devin
  '@cognition/devin',
  '@devin/sdk',
  'devin-ai',
  
  // Sourcegraph Cody
  '@sourcegraph/cody',
  '@sourcegraph/cody-agent',
  '@sourcegraph/cody-shared',
  'cody-ai',
  
  // JetBrains AI
  '@jetbrains/ai',
  '@jetbrains/ai-assistant',
  'jetbrains-ai',
  
  // Continue.dev
  '@continue/core',
  '@continue/sdk',
  'continue-ai',
];

// Proprietary CDN domains
export const PROPRIETARY_ASSET_CDNS: string[] = [
  'cdn.lovable.app',
  'cdn.lovable.dev',
  'bolt-assets',
  'assets.bolt.new',
  'cdn.bolt.new',
  'assets.gptengineer.app',
  'cdn.gptengineer.app',
  'storage.lovable.app',
  'storage.lovable.dev',
  'assets.v0.dev',
  'cdn.v0.dev',
  
  // ============= NEW AI PLATFORMS CDNs =============
  'cdn.codeium.com',
  'assets.windsurf.ai',
  'cdn.tabnine.com',
  'assets.devin.ai',
  'cdn.cognition.ai',
  'assets.sourcegraph.com',
  'cdn.continue.dev',
];

// ============= AUTO-POLYFILL DEFINITIONS =============

export const HOOK_POLYFILLS: Record<string, { filename: string; content: string }> = {
  'use-mobile': {
    filename: 'use-mobile.ts',
    content: `import { useState, useEffect } from 'react';

/**
 * Hook to detect mobile viewport
 * Auto-generated polyfill by Inopay Liberation
 */
export function useIsMobile() {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < 768);
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  return isMobile;
}

export default useIsMobile;`,
  },
  'use-toast': {
    filename: 'use-toast.ts',
    content: `import { useState, useCallback } from 'react';

/**
 * Simple toast notification hook
 * Auto-generated polyfill by Inopay Liberation
 */
export interface Toast {
  id: string;
  title?: string;
  description?: string;
  variant?: 'default' | 'destructive';
}

let toastCount = 0;

export function useToast() {
  const [toasts, setToasts] = useState<Toast[]>([]);

  const toast = useCallback(({ title, description, variant = 'default' }: Omit<Toast, 'id'>) => {
    const id = String(++toastCount);
    const newToast: Toast = { id, title, description, variant };
    setToasts(prev => [...prev, newToast]);
    
    setTimeout(() => {
      setToasts(prev => prev.filter(t => t.id !== id));
    }, 5000);
    
    return { id, dismiss: () => setToasts(prev => prev.filter(t => t.id !== id)) };
  }, []);

  const dismiss = useCallback((id: string) => {
    setToasts(prev => prev.filter(t => t.id !== id));
  }, []);

  return { toast, toasts, dismiss };
}

export default useToast;`,
  },
  'use-sidebar': {
    filename: 'use-sidebar.ts',
    content: `import { useState, useCallback, createContext, useContext } from 'react';

/**
 * Sidebar state management hook
 * Auto-generated polyfill by Inopay Liberation
 */
export interface SidebarState {
  isOpen: boolean;
  toggle: () => void;
  open: () => void;
  close: () => void;
}

const SidebarContext = createContext<SidebarState | null>(null);

export function useSidebar(): SidebarState {
  const context = useContext(SidebarContext);
  const [isOpen, setIsOpen] = useState(true);
  
  if (context) return context;
  
  return {
    isOpen,
    toggle: () => setIsOpen(prev => !prev),
    open: () => setIsOpen(true),
    close: () => setIsOpen(false),
  };
}

export { SidebarContext };
export default useSidebar;`,
  },
  'supabase-client': {
    filename: 'supabase-client.ts',
    content: `import { createClient } from '@supabase/supabase-js';

/**
 * Supabase client configuration
 * Auto-generated by Inopay Liberation - Configure your own Supabase project
 */

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  console.warn('Missing Supabase environment variables. Please configure VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY');
}

export const supabase = createClient(
  supabaseUrl || 'https://your-project.supabase.co',
  supabaseAnonKey || 'your-anon-key',
  {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
    },
  }
);

export default supabase;`,
  },
  'use-auth': {
    filename: 'use-auth.ts',
    content: `import { useState, useEffect, createContext, useContext, ReactNode } from 'react';
import { supabase } from './supabase-client';
import type { User, Session } from '@supabase/supabase-js';

/**
 * Authentication hook
 * Auto-generated polyfill by Inopay Liberation
 */
export interface AuthContextType {
  user: User | null;
  session: Session | null;
  loading: boolean;
  signIn: (email: string, password: string) => Promise<void>;
  signUp: (email: string, password: string) => Promise<void>;
  signOut: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | null>(null);

export function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  const [user, setUser] = useState<User | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setUser(session?.user ?? null);
      setLoading(false);
    });

    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (_event, session) => {
        setSession(session);
        setUser(session?.user ?? null);
      }
    );

    return () => subscription.unsubscribe();
  }, []);

  if (context) return context;

  return {
    user,
    session,
    loading,
    signIn: async (email, password) => {
      const { error } = await supabase.auth.signInWithPassword({ email, password });
      if (error) throw error;
    },
    signUp: async (email, password) => {
      const { error } = await supabase.auth.signUp({ email, password });
      if (error) throw error;
    },
    signOut: async () => {
      const { error } = await supabase.auth.signOut();
      if (error) throw error;
    },
  };
}

export { AuthContext };
export default useAuth;`,
  },
};

// ============= UTILITY FUNCTIONS =============

/**
 * Check if file should be completely removed
 */
export function shouldRemoveFile(filePath: string): boolean {
  const fileName = filePath.split('/').pop() || '';
  
  // Check exact file matches
  for (const pattern of PROPRIETARY_FILES) {
    if (fileName === pattern || filePath.includes(`/${pattern}`) || filePath.endsWith(pattern)) {
      return true;
    }
  }
  
  // Check path patterns
  for (const pathPattern of PROPRIETARY_PATHS) {
    if (filePath.includes(pathPattern)) {
      return true;
    }
  }
  
  // NEW: Remove any file in integrations folder
  if (filePath.includes('/integrations/')) {
    return true;
  }
  
  return false;
}

/**
 * Check if content contains proprietary patterns (basic check)
 */
export function needsCleaning(content: string): boolean {
  // Check proprietary imports
  for (const pattern of PROPRIETARY_IMPORTS) {
    const regex = new RegExp(pattern.source, pattern.flags);
    if (regex.test(content)) return true;
  }
  
  // Check for telemetry domains
  for (const domain of TELEMETRY_DOMAINS) {
    if (content.includes(domain)) return true;
  }
  
  // Check for suspicious packages in package.json
  if (content.includes('"dependencies"') || content.includes('"devDependencies"')) {
    for (const pkg of SUSPICIOUS_PACKAGES) {
      if (content.includes(`"${pkg}"`)) return true;
    }
  }
  
  // Check for @/integrations path
  if (content.includes('@/integrations/supabase')) return true;
  if (content.includes('integrations/supabase')) return true;
  
  // NEW: Check for hardcoded Supabase project IDs
  for (const pattern of SUPABASE_PROJECT_PATTERNS) {
    if (pattern.test(content)) return true;
  }
  
  return false;
}

/**
 * DEEP CLEAN V3: Maximum sovereignty cleaning with multiple passes
 * This function cleans ALL source files systematically with exhaustive checks
 */
export function deepCleanSourceFile(content: string, filePath: string): { 
  cleaned: string; 
  changes: string[]; 
  wasModified: boolean;
  suspiciousPatterns: string[];
} {
  const changes: string[] = [];
  const suspiciousPatterns: string[] = [];
  let cleaned = content;
  const originalContent = content;

  // ========== PASS 1: Remove ALL proprietary import statements ==========
  const importPatterns = [
    // Lovable/GPT Engineer imports
    { pattern: /import\s*{\s*componentTagger\s*}\s*from\s*['"]lovable-tagger['"]\s*;?\n?/g, name: 'lovable-tagger import' },
    { pattern: /import\s*[^;]*\s*from\s*['"]@lovable\/[^'"]*['"]\s*;?\n?/g, name: '@lovable import' },
    { pattern: /import\s*[^;]*\s*from\s*['"]@gptengineer\/[^'"]*['"]\s*;?\n?/g, name: '@gptengineer import' },
    { pattern: /import\s*[^;]*\s*from\s*['"]lovable-[^'"]*['"]\s*;?\n?/g, name: 'lovable- import' },
    { pattern: /import\s*[^;]*\s*from\s*['"]@v0\/[^'"]*['"]\s*;?\n?/g, name: '@v0 import' },
    { pattern: /import\s*[^;]*\s*from\s*['"]@bolt\/[^'"]*['"]\s*;?\n?/g, name: '@bolt import' },
    { pattern: /import\s*[^;]*\s*from\s*['"]@cursor\/[^'"]*['"]\s*;?\n?/g, name: '@cursor import' },
    { pattern: /import\s*[^;]*\s*from\s*['"]@replit\/[^'"]*['"]\s*;?\n?/g, name: '@replit import' },
  ];

  for (const { pattern, name } of importPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, '');
    if (cleaned !== before) {
      changes.push(`Import propriétaire supprimé: ${name}`);
    }
  }

  // ========== PASS 2: Replace @/integrations/supabase paths with lib paths ==========
  // CRITICAL FIX: Do replacement directly without .test() to avoid consuming regex
  const supabaseImportReplacements = [
    { pattern: /from\s*['"]@\/integrations\/supabase\/client['"]/g, replacement: "from '@/lib/supabase-client'" },
    { pattern: /from\s*['"]@\/integrations\/supabase\/types['"]/g, replacement: "from '@/lib/supabase-types'" },
    { pattern: /from\s*['"]@\/integrations\/supabase[^'"]*['"]/g, replacement: "from '@/lib/supabase-client'" },
    { pattern: /from\s*['"]\.\.\/integrations\/supabase\/client['"]/g, replacement: "from '@/lib/supabase-client'" },
    { pattern: /from\s*['"]\.\.\/\.\.\/integrations\/supabase\/client['"]/g, replacement: "from '@/lib/supabase-client'" },
    { pattern: /from\s*['"]\.\.\/\.\.\/\.\.\/integrations\/supabase\/client['"]/g, replacement: "from '@/lib/supabase-client'" },
    { pattern: /from\s*['"]\.\.\/integrations\/supabase\/types['"]/g, replacement: "from '@/lib/supabase-types'" },
    { pattern: /from\s*['"]\.\.\/\.\.\/integrations\/supabase\/types['"]/g, replacement: "from '@/lib/supabase-types'" },
    { pattern: /from\s*['"]\.+\/integrations\/supabase[^'"]*['"]/g, replacement: "from '@/lib/supabase-client'" },
  ];

  for (const { pattern, replacement } of supabaseImportReplacements) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, replacement);
    if (cleaned !== before) {
      changes.push('Imports Supabase redirigés vers @/lib/');
    }
  }

  // ========== PASS 3: Remove ALL proprietary content patterns ==========
  const contentPatterns = [
    // Plugin usage in vite.config
    { pattern: /mode\s*===\s*['"]development['"]\s*&&\s*componentTagger\(\)\s*,?\n?/g, name: 'componentTagger plugin' },
    { pattern: /componentTagger\(\)\s*,?\n?/g, name: 'componentTagger call' },
    // Comment markers
    { pattern: /\/\/\s*@lovable[^\n]*\n?/gi, name: '@lovable comment' },
    { pattern: /\/\*\s*@lovable[\s\S]*?\*\//g, name: '@lovable block comment' },
    { pattern: /\/\/\s*@gptengineer[^\n]*\n?/gi, name: '@gptengineer comment' },
    { pattern: /\/\*\s*@gptengineer[\s\S]*?\*\//g, name: '@gptengineer block comment' },
    { pattern: /\/\/\s*@bolt[^\n]*\n?/gi, name: '@bolt comment' },
    { pattern: /\/\/\s*@v0[^\n]*\n?/gi, name: '@v0 comment' },
    { pattern: /\/\/\s*Generated by Lovable[^\n]*\n?/gi, name: 'Generated by Lovable' },
    { pattern: /\/\/\s*Auto-generated[^\n]*lovable[^\n]*\n?/gi, name: 'Auto-generated lovable' },
    { pattern: /\/\/\s*Built with Lovable[^\n]*\n?/gi, name: 'Built with Lovable' },
    { pattern: /\/\*[\s\S]*?lovable[\s\S]*?\*\//gi, name: 'lovable block comment' },
    // Data attributes
    { pattern: /\s*data-lovable[^=]*="[^"]*"/g, name: 'data-lovable attr' },
    { pattern: /\s*data-lov-[^=]*="[^"]*"/g, name: 'data-lov attr' },
    { pattern: /\s*data-gpt[^=]*="[^"]*"/g, name: 'data-gpt attr' },
    { pattern: /\s*data-bolt[^=]*="[^"]*"/g, name: 'data-bolt attr' },
    { pattern: /\s*data-v0[^=]*="[^"]*"/g, name: 'data-v0 attr' },
  ];

  for (const { pattern, name } of contentPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, '');
    if (cleaned !== before) {
      changes.push(`Pattern nettoyé: ${name}`);
    }
  }

  // ========== PASS 4: Remove telemetry domain references ==========
  for (const domain of TELEMETRY_DOMAINS) {
    const escapedDomain = domain.replace(/\./g, '\\.');
    const domainPattern = new RegExp(`['"\`][^'"\`]*${escapedDomain}[^'"\`]*['"\`]`, 'gi');
    const before = cleaned;
    cleaned = cleaned.replace(domainPattern, '""');
    if (cleaned !== before) {
      changes.push(`Télémétrie supprimée: ${domain}`);
    }
  }

  // ========== PASS 5: Clean hardcoded Supabase project IDs ==========
  const supabaseIdPatterns = [
    { pattern: /[a-z]{20}\.supabase\.co/g, replacement: 'your-project.supabase.co', name: 'Supabase project URL' },
    { pattern: /eyJ[A-Za-z0-9_-]{100,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g, replacement: 'YOUR_SUPABASE_KEY', name: 'JWT token' },
  ];

  for (const { pattern, replacement, name } of supabaseIdPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, replacement);
    if (cleaned !== before) {
      changes.push(`ID remplacé: ${name}`);
    }
  }

  // ========== PASS 6: Remove exposed API keys ==========
  const keyPatterns = [
    { pattern: /sk_live_[A-Za-z0-9]{20,}/g, replacement: 'sk_live_YOUR_KEY', name: 'Stripe live secret key' },
    { pattern: /pk_live_[A-Za-z0-9]{20,}/g, replacement: 'pk_live_YOUR_KEY', name: 'Stripe live public key' },
    { pattern: /sk_test_[A-Za-z0-9]{20,}/g, replacement: 'sk_test_YOUR_KEY', name: 'Stripe test secret key' },
    { pattern: /pk_test_[A-Za-z0-9]{20,}/g, replacement: 'pk_test_YOUR_KEY', name: 'Stripe test public key' },
  ];

  for (const { pattern, replacement, name } of keyPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, replacement);
    if (cleaned !== before) {
      suspiciousPatterns.push(`Clé exposée détectée dans ${filePath}: ${name}`);
      changes.push(`Clé nettoyée: ${name}`);
    }
  }

  // ========== PASS 7: Remove data-* attributes specific to platforms ==========
  const dataAttrPatterns = [
    /\s*data-lovable[^=]*="[^"]*"/g,
    /\s*data-lov-[^=]*="[^"]*"/g,
    /\s*data-gpt[^=]*="[^"]*"/g,
    /\s*data-bolt[^=]*="[^"]*"/g,
    /\s*data-v0[^=]*="[^"]*"/g,
    /\s*data-cursor[^=]*="[^"]*"/g,
    /\s*data-replit[^=]*="[^"]*"/g,
  ];

  for (const pattern of dataAttrPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, '');
    if (cleaned !== before) {
      changes.push('Attributs data-* supprimés');
    }
  }

  // ========== PASS 8: Detect and remove hidden telemetry ==========
  const hiddenTelemetryPatterns = [
    { pattern: /fetch\s*\([^)]*lovable[^)]*\)/gi, name: 'fetch lovable' },
    { pattern: /fetch\s*\([^)]*gptengineer[^)]*\)/gi, name: 'fetch gptengineer' },
    { pattern: /navigator\.sendBeacon\s*\([^)]*lovable[^)]*\)/gi, name: 'sendBeacon lovable' },
    { pattern: /navigator\.sendBeacon\s*\([^)]*gptengineer[^)]*\)/gi, name: 'sendBeacon gptengineer' },
    { pattern: /new\s+WebSocket\s*\([^)]*lovable[^)]*\)/gi, name: 'WebSocket lovable' },
    { pattern: /new\s+WebSocket\s*\([^)]*gptengineer[^)]*\)/gi, name: 'WebSocket gptengineer' },
  ];

  for (const { pattern, name } of hiddenTelemetryPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, '/* REMOVED: telemetry */');
    if (cleaned !== before) {
      suspiciousPatterns.push(`Appel suspect supprimé: ${name}`);
      changes.push(`Télémétrie supprimée: ${name}`);
    }
  }

  // ========== PASS 9: Remove VITE_ env vars that are proprietary ==========
  const envVarPatterns = [
    { pattern: /import\.meta\.env\.VITE_LOVABLE_[A-Z_]+/g, name: 'VITE_LOVABLE_*' },
    { pattern: /import\.meta\.env\.VITE_GPT_[A-Z_]+/g, name: 'VITE_GPT_*' },
    { pattern: /process\.env\.VITE_LOVABLE_[A-Z_]+/g, name: 'process.env VITE_LOVABLE_*' },
    { pattern: /process\.env\.VITE_GPT_[A-Z_]+/g, name: 'process.env VITE_GPT_*' },
  ];

  for (const { pattern, name } of envVarPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, '""');
    if (cleaned !== before) {
      changes.push(`Variable env supprimée: ${name}`);
    }
  }

  // ========== PASS 10: Remove proprietary comments (comprehensive) ==========
  const commentPatterns = [
    { pattern: /\/\/\s*@lovable[^\n]*\n?/gi, name: '@lovable comment' },
    { pattern: /\/\/\s*@gptengineer[^\n]*\n?/gi, name: '@gptengineer comment' },
    { pattern: /\/\/\s*Generated by Lovable[^\n]*\n?/gi, name: 'Generated by Lovable' },
    { pattern: /\/\/\s*Built with Lovable[^\n]*\n?/gi, name: 'Built with Lovable' },
    { pattern: /\/\/\s*Created with GPT Engineer[^\n]*\n?/gi, name: 'Created with GPT Engineer' },
    { pattern: /\/\*\s*@lovable[\s\S]*?\*\//gi, name: '@lovable block' },
    { pattern: /\/\*\s*@gptengineer[\s\S]*?\*\//gi, name: '@gptengineer block' },
    { pattern: /<!--[\s\S]*?lovable[\s\S]*?-->/gi, name: 'lovable HTML comment' },
    { pattern: /<!--[\s\S]*?gptengineer[\s\S]*?-->/gi, name: 'gptengineer HTML comment' },
  ];

  for (const { pattern, name } of commentPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, '');
    if (cleaned !== before) {
      changes.push(`Commentaire supprimé: ${name}`);
    }
  }

  // ========== FINAL: Clean up excessive whitespace and empty imports ==========
  cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
  cleaned = cleaned.replace(/import\s*{\s*}\s*from\s*['"][^'"]*['"]\s*;?\n?/g, '');
  
  // Remove trailing commas in plugin arrays
  cleaned = cleaned.replace(/,\s*,/g, ',');
  cleaned = cleaned.replace(/\[\s*,/g, '[');
  cleaned = cleaned.replace(/,\s*\]/g, ']');

  const wasModified = cleaned !== originalContent;

  return { cleaned, changes: [...new Set(changes)], wasModified, suspiciousPatterns };
}

/**
 * Clean package.json from proprietary packages - EXHAUSTIVE
 */
export function cleanPackageJson(content: string): { cleaned: string; changes: string[] } {
  const changes: string[] = [];
  
  try {
    const pkg = JSON.parse(content);
    
    // Remove suspicious packages
    for (const dep of SUSPICIOUS_PACKAGES) {
      if (pkg.dependencies?.[dep]) {
        delete pkg.dependencies[dep];
        changes.push(`Dépendance supprimée: ${dep}`);
      }
      if (pkg.devDependencies?.[dep]) {
        delete pkg.devDependencies[dep];
        changes.push(`DevDépendance supprimée: ${dep}`);
      }
    }
    
    // Clean scripts that reference proprietary tools
    if (pkg.scripts) {
      const scriptsToRemove = ['lovable', 'gpteng', 'bolt', 'v0', 'cursor', 'replit'];
      const keysToDelete: string[] = [];
      for (const [key, value] of Object.entries(pkg.scripts)) {
        if (typeof value === 'string') {
          for (const term of scriptsToRemove) {
            if (value.toLowerCase().includes(term)) {
              keysToDelete.push(key);
              changes.push(`Script supprimé: ${key}`);
              break;
            }
          }
        }
      }
      keysToDelete.forEach(key => delete pkg.scripts[key]);
    }
    
    // Remove repository fields pointing to proprietary platforms
    const proprietaryDomains = ['lovable', 'gptengineer', 'bolt.new', 'v0.dev', 'cursor', 'replit'];
    if (pkg.repository?.url) {
      for (const domain of proprietaryDomains) {
        if (pkg.repository.url.includes(domain)) {
          delete pkg.repository;
          changes.push('Repository propriétaire supprimé');
          break;
        }
      }
    }
    
    // Remove homepage if it points to proprietary platforms
    if (pkg.homepage) {
      for (const domain of proprietaryDomains) {
        if (pkg.homepage.includes(domain)) {
          delete pkg.homepage;
          changes.push('Homepage propriétaire supprimée');
          break;
        }
      }
    }
    
    // Remove bugs URL if proprietary
    if (pkg.bugs?.url) {
      for (const domain of proprietaryDomains) {
        if (pkg.bugs.url.includes(domain)) {
          delete pkg.bugs;
          changes.push('Bugs URL propriétaire supprimée');
          break;
        }
      }
    }
    
    // Remove author if it contains proprietary references
    if (typeof pkg.author === 'string') {
      for (const domain of proprietaryDomains) {
        if (pkg.author.toLowerCase().includes(domain)) {
          delete pkg.author;
          changes.push('Author propriétaire supprimé');
          break;
        }
      }
    }
    
    return { cleaned: JSON.stringify(pkg, null, 2), changes };
  } catch (e) {
    console.error('Error cleaning package.json:', e);
    return { cleaned: content, changes };
  }
}

/**
 * Clean vite.config.ts from proprietary plugins - EXHAUSTIVE
 */
export function cleanViteConfig(content: string): { cleaned: string; changes: string[] } {
  const changes: string[] = [];
  let cleaned = content;
  
  const before = cleaned;
  
  // Remove all proprietary imports
  const importPatterns = [
    /import\s*{\s*componentTagger\s*}\s*from\s*['"]lovable-tagger['"]\s*;?\n?/g,
    /import\s*.*\s*from\s*['"]@lovable\/[^'"]*['"]\s*;?\n?/g,
    /import\s*.*\s*from\s*['"]@gptengineer\/[^'"]*['"]\s*;?\n?/g,
    /import\s*.*\s*from\s*['"]lovable-[^'"]*['"]\s*;?\n?/g,
    /import\s*.*\s*from\s*['"]@v0\/[^'"]*['"]\s*;?\n?/g,
    /import\s*.*\s*from\s*['"]@bolt\/[^'"]*['"]\s*;?\n?/g,
  ];
  
  for (const pattern of importPatterns) {
    cleaned = cleaned.replace(pattern, '');
  }
  
  // Remove plugin usages
  const pluginPatterns = [
    /mode\s*===\s*['"]development['"]\s*&&\s*componentTagger\(\)\s*,?\n?/g,
    /componentTagger\(\)\s*,?\n?/g,
    /lovableTagger\(\)\s*,?\n?/g,
    /gptEngineer\(\)\s*,?\n?/g,
  ];
  
  for (const pattern of pluginPatterns) {
    cleaned = cleaned.replace(pattern, '');
  }
  
  // Clean empty plugin arrays and trailing commas
  cleaned = cleaned.replace(/plugins:\s*\[\s*,?\s*\]/g, 'plugins: []');
  cleaned = cleaned.replace(/,\s*,/g, ',');
  cleaned = cleaned.replace(/\[\s*,/g, '[');
  cleaned = cleaned.replace(/,\s*\]/g, ']');
  cleaned = cleaned.replace(/,\s*\)/g, ')');
  
  if (cleaned !== before) {
    changes.push('vite.config.ts nettoyé des plugins propriétaires');
  }
  
  return { cleaned, changes };
}

/**
 * Clean index.html from proprietary scripts and data attributes - EXHAUSTIVE
 */
export function cleanIndexHtml(content: string): { cleaned: string; changes: string[] } {
  const changes: string[] = [];
  let cleaned = content;
  
  const before = cleaned;
  
  // Remove script tags with proprietary references
  const scriptPatterns = [
    /<script[^>]*lovable[^>]*>[\s\S]*?<\/script>/gi,
    /<script[^>]*gptengineer[^>]*>[\s\S]*?<\/script>/gi,
    /<script[^>]*bolt[^>]*>[\s\S]*?<\/script>/gi,
    /<script[^>]*v0[^>]*>[\s\S]*?<\/script>/gi,
    /<script[^>]*cursor[^>]*>[\s\S]*?<\/script>/gi,
    /<script[^>]*replit[^>]*>[\s\S]*?<\/script>/gi,
  ];
  
  for (const pattern of scriptPatterns) {
    cleaned = cleaned.replace(pattern, '');
  }
  
  // Remove data attributes
  const dataAttrPatterns = [
    /\s*data-lov[^=]*="[^"]*"/g,
    /\s*data-gpt[^=]*="[^"]*"/g,
    /\s*data-bolt[^=]*="[^"]*"/g,
    /\s*data-v0[^=]*="[^"]*"/g,
    /\s*data-lovable[^=]*="[^"]*"/g,
  ];
  
  for (const pattern of dataAttrPatterns) {
    cleaned = cleaned.replace(pattern, '');
  }
  
  // Remove meta tags with proprietary references
  const metaPatterns = [
    /<meta[^>]*lovable[^>]*\/?>/gi,
    /<meta[^>]*gptengineer[^>]*\/?>/gi,
    /<meta[^>]*generator[^>]*lovable[^>]*\/?>/gi,
    /<meta[^>]*generator[^>]*gpt[^>]*\/?>/gi,
  ];
  
  for (const pattern of metaPatterns) {
    cleaned = cleaned.replace(pattern, '');
  }
  
  // Remove link tags to proprietary resources
  const linkPatterns = [
    /<link[^>]*lovable[^>]*\/?>/gi,
    /<link[^>]*gptengineer[^>]*\/?>/gi,
    /<link[^>]*bolt\.new[^>]*\/?>/gi,
  ];
  
  for (const pattern of linkPatterns) {
    cleaned = cleaned.replace(pattern, '');
  }
  
  // Remove comments with proprietary references
  cleaned = cleaned.replace(/<!--[\s\S]*?lovable[\s\S]*?-->/gi, '');
  cleaned = cleaned.replace(/<!--[\s\S]*?gptengineer[\s\S]*?-->/gi, '');
  
  if (cleaned !== before) {
    changes.push('index.html nettoyé des scripts et attributs propriétaires');
  }
  
  return { cleaned, changes };
}

/**
 * Clean CSS/SCSS files from proprietary references
 */
export function cleanStylesheet(content: string): { cleaned: string; changes: string[] } {
  const changes: string[] = [];
  let cleaned = content;
  const before = cleaned;
  
  // Remove CDN references
  for (const cdn of PROPRIETARY_ASSET_CDNS) {
    const cdnPattern = new RegExp(`url\\s*\\([^)]*${cdn.replace(/\./g, '\\.')}[^)]*\\)`, 'gi');
    if (cdnPattern.test(cleaned)) {
      cleaned = cleaned.replace(cdnPattern, 'url("")');
      changes.push(`CDN propriétaire supprimé: ${cdn}`);
    }
  }
  
  // Remove comments with proprietary references
  cleaned = cleaned.replace(/\/\*[\s\S]*?lovable[\s\S]*?\*\//gi, '');
  cleaned = cleaned.replace(/\/\*[\s\S]*?gptengineer[\s\S]*?\*\//gi, '');
  
  if (cleaned !== before) {
    changes.push('Stylesheet nettoyé');
  }
  
  return { cleaned, changes };
}

/**
 * Clean tsconfig.json from proprietary paths
 */
export function cleanTsConfig(content: string): { cleaned: string; changes: string[] } {
  const changes: string[] = [];
  
  try {
    const config = JSON.parse(content);
    
    // Remove paths pointing to integrations
    if (config.compilerOptions?.paths) {
      const pathsToRemove = Object.keys(config.compilerOptions.paths).filter(
        key => key.includes('integrations') || key.includes('lovable') || key.includes('gptengineer')
      );
      
      for (const path of pathsToRemove) {
        delete config.compilerOptions.paths[path];
        changes.push(`Path supprimé: ${path}`);
      }
    }
    
    // Remove include patterns for integrations
    if (Array.isArray(config.include)) {
      config.include = config.include.filter(
        (inc: string) => !inc.includes('integrations') && !inc.includes('lovable')
      );
    }
    
    return { cleaned: JSON.stringify(config, null, 2), changes };
  } catch (e) {
    return { cleaned: content, changes };
  }
}

/**
 * Clean source file from proprietary patterns (basic client-side cleaning)
 * @deprecated Use deepCleanSourceFile for comprehensive cleaning
 */
export function cleanSourceFile(content: string): { cleaned: string; changes: string[] } {
  const changes: string[] = [];
  let cleaned = content;
  
  // Remove proprietary content patterns
  for (const pattern of PROPRIETARY_CONTENT) {
    const regex = new RegExp(pattern.source, pattern.flags);
    if (regex.test(cleaned)) {
      cleaned = cleaned.replace(new RegExp(pattern.source, pattern.flags), '');
      changes.push(`Pattern supprimé: ${pattern.source.substring(0, 30)}...`);
    }
  }
  
  // Remove telemetry domain references
  for (const domain of TELEMETRY_DOMAINS) {
    const domainPattern = new RegExp(`['"\`][^'"\`]*${domain.replace(/\./g, '\\.')}[^'"\`]*['"\`]`, 'gi');
    if (domainPattern.test(cleaned)) {
      cleaned = cleaned.replace(domainPattern, '""');
      changes.push(`Télémétrie supprimée: ${domain}`);
    }
  }
  
  // Clean up empty lines left behind
  cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
  
  return { cleaned, changes };
}

/**
 * Check for proprietary CDN assets
 */
export function checkProprietaryCDN(content: string): { found: boolean; urls: string[] } {
  const urls: string[] = [];
  
  for (const cdn of PROPRIETARY_ASSET_CDNS) {
    const regex = new RegExp(`https?://[^'"\\s]*${cdn.replace(/\./g, '\\.')}[^'"\\s]*`, 'gi');
    const matches = content.match(regex);
    if (matches) {
      urls.push(...matches);
    }
  }
  
  return { found: urls.length > 0, urls };
}

/**
 * Detect which polyfills are needed based on file content - EXHAUSTIVE
 */
export function detectNeededPolyfills(files: Map<string, string>): string[] {
  const needed = new Set<string>();
  
  for (const [path, content] of files) {
    if (!path.match(/\.(ts|tsx|js|jsx)$/)) continue;
    
    // Check for use-mobile
    if (/useIsMobile|use-mobile|useMobile/i.test(content)) {
      if (/@lovable|@gptengineer|lovable-|gptengineer-|@\/hooks\/use-mobile|@\/components\/ui\/.*mobile/i.test(content)) {
        needed.add('use-mobile');
      }
    }
    
    // Check for use-toast 
    if (/useToast|use-toast/i.test(content)) {
      if (/@lovable|@gptengineer|lovable-|gptengineer-|@\/hooks\/use-toast|@\/components\/ui\/use-toast/i.test(content)) {
        needed.add('use-toast');
      }
    }
    
    // Check for use-sidebar
    if (/useSidebar|use-sidebar/i.test(content)) {
      if (/@lovable|@gptengineer|lovable-|gptengineer-|@\/hooks\/use-sidebar|@\/components\/ui\/sidebar/i.test(content)) {
        needed.add('use-sidebar');
      }
    }
    
    // Check for Supabase client usage
    if (/@\/integrations\/supabase\/client/i.test(content)) {
      needed.add('supabase-client');
    }
    
    // Check for useAuth
    if (/useAuth/i.test(content)) {
      if (/@\/hooks\/useAuth|@\/integrations\/supabase/i.test(content)) {
        needed.add('use-auth');
        needed.add('supabase-client');
      }
    }
  }
  
  return Array.from(needed);
}

/**
 * Generate .env.example from detected environment variables
 */
export function generateEnvExample(files: Map<string, string>): string {
  const envVars = new Set<string>();
  
  for (const [, content] of files) {
    // Match VITE_ and REACT_APP_ environment variables
    const matches = content.matchAll(/(?:import\.meta\.env\.|process\.env\.)(VITE_[A-Z_]+|REACT_APP_[A-Z_]+)/g);
    for (const match of matches) {
      // Skip proprietary env vars
      if (!match[1].includes('LOVABLE') && !match[1].includes('GPT') && !match[1].includes('PROJECT_ID')) {
        envVars.add(match[1]);
      }
    }
  }
  
  // Always include essential Supabase vars
  envVars.add('VITE_SUPABASE_URL');
  envVars.add('VITE_SUPABASE_ANON_KEY');
  
  let result = `# Variables d'environnement - Généré par Inopay Liberation
# Configurez ces valeurs avec votre propre infrastructure

# === SUPABASE (ou votre base de données) ===
VITE_SUPABASE_URL=https://your-project.supabase.co
VITE_SUPABASE_ANON_KEY=your-anon-key

`;
  
  for (const v of envVars) {
    if (!v.includes('SUPABASE')) {
      result += `${v}=\n`;
    }
  }
  
  return result;
}

/**
 * Calculate sovereignty score (0-100) - WEIGHTED SYSTEM
 */
export function calculateSovereigntyScore(
  originalFiles: Map<string, string>,
  cleanedFiles: Record<string, string>
): { score: number; details: string[] } {
  const details: string[] = [];
  let score = 100;
  
  // Check for remaining proprietary patterns in cleaned files
  for (const [path, content] of Object.entries(cleanedFiles)) {
    // CRITICAL: -20 points each
    // Check for remaining @/integrations imports
    if (/@\/integrations\/supabase/.test(content)) {
      score -= 20;
      details.push(`CRITIQUE: Import @/integrations restant dans ${path}`);
    }
    
    // Check for hardcoded Supabase project IDs
    for (const pattern of SUPABASE_PROJECT_PATTERNS) {
      if (new RegExp(pattern.source, pattern.flags).test(content)) {
        score -= 20;
        details.push(`CRITIQUE: ID Supabase hardcodé dans ${path}`);
        break;
      }
    }
    
    // Check for exposed API keys
    for (const pattern of EXPOSED_KEYS_PATTERNS) {
      if (new RegExp(pattern.source, pattern.flags).test(content)) {
        score -= 20;
        details.push(`CRITIQUE: Clé API exposée dans ${path}`);
        break;
      }
    }
    
    // MAJOR: -10 points each
    // Check for remaining proprietary imports
    for (const pattern of PROPRIETARY_IMPORTS) {
      if (new RegExp(pattern.source, pattern.flags).test(content)) {
        score -= 10;
        details.push(`MAJEUR: Import propriétaire dans ${path}`);
        break;
      }
    }
    
    // Check for telemetry domains
    for (const domain of TELEMETRY_DOMAINS) {
      if (content.includes(domain)) {
        score -= 10;
        details.push(`MAJEUR: Télémétrie ${domain} dans ${path}`);
        break;
      }
    }
    
    // Check for proprietary CDN
    const cdnCheck = checkProprietaryCDN(content);
    if (cdnCheck.found) {
      score -= 10;
      details.push(`MAJEUR: CDN propriétaire dans ${path}`);
    }
    
    // MINOR: -5 points each
    // Check for data attributes
    if (/data-lov|data-gpt|data-bolt|data-v0/.test(content)) {
      score -= 5;
      details.push(`MINEUR: Data attribute dans ${path}`);
    }
    
    // Check for proprietary comments
    if (/lovable|gptengineer/i.test(content) && /\/\/|\/\*|<!--|#/.test(content)) {
      // Only flag if it's in a comment context
      if (/\/\/.*lovable|\/\*.*lovable|<!--.*lovable/i.test(content)) {
        score -= 5;
        details.push(`MINEUR: Commentaire propriétaire dans ${path}`);
      }
    }
  }
  
  // BONUS: +5 points for good practices
  // Check if polyfills were generated
  if (Object.keys(cleanedFiles).some(p => p.includes('inopay-compat'))) {
    score = Math.min(100, score + 5);
  }
  
  // Check if .env.example exists
  if (Object.keys(cleanedFiles).some(p => p.includes('.env.example'))) {
    score = Math.min(100, score + 5);
  }
  
  return { 
    score: Math.max(0, Math.min(100, score)), 
    details: details.slice(0, 15) // Limit to 15 issues
  };
}

/**
 * Final verification pass - ensures 100% sovereignty
 */
export function finalVerificationPass(
  cleanedFiles: Record<string, string>
): { isClean: boolean; remainingIssues: string[]; criticalCount: number } {
  const remainingIssues: string[] = [];
  let criticalCount = 0;
  
  for (const [path, content] of Object.entries(cleanedFiles)) {
    // Skip non-source files
    if (!path.match(/\.(ts|tsx|js|jsx|json|html|css|scss)$/)) continue;
    
    // Check for any remaining proprietary references
    const criticalPatterns = [
      { pattern: /@\/integrations\/supabase/g, name: 'Import Supabase auto-généré' },
      { pattern: /lovable\.app|lovable\.dev|gptengineer\.app/gi, name: 'Domaine Lovable' },
      { pattern: /izqveyvcebolrqpqlmho/g, name: 'ID projet Supabase' },
      { pattern: /eyJ[A-Za-z0-9_-]{100,}/g, name: 'Token JWT hardcodé' },
    ];
    
    for (const { pattern, name } of criticalPatterns) {
      if (pattern.test(content)) {
        remainingIssues.push(`${path}: ${name}`);
        criticalCount++;
      }
    }
  }
  
  return {
    isClean: remainingIssues.length === 0,
    remainingIssues,
    criticalCount,
  };
}
