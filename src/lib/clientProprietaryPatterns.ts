/**
 * Client-compatible proprietary patterns for code cleaning
 * Centralized patterns used by zipAnalyzer and SimpleLiberationFlow
 * This is a client-side version of supabase/functions/_shared/proprietary-patterns.ts
 * 
 * ENHANCED: Version 3.0 - MAXIMUM SOVEREIGNTY with exhaustive patterns
 */

// ============= PROPRIETARY PATTERNS TO DETECT =============

export const PROPRIETARY_IMPORTS: RegExp[] = [
  // Lovable / GPT Engineer patterns
  /@lovable\//g,
  /@gptengineer\//g,
  /from ['"]lovable/g,
  /from ['"]gptengineer/g,
  /from ['"]@lovable/g,
  /from ['"]@gptengineer/g,
  /lovable-tagger/g,
  /componentTagger/g,
  /lovable-core/g,
  /gpt-engineer/g,
  
  // Bolt patterns
  /@bolt\//g,
  /from ['"]bolt/g,
  /from ['"]@bolt/g,
  
  // v0 (Vercel) patterns
  /@v0\//g,
  /from ['"]v0/g,
  /from ['"]@v0/g,
  /v0-tagger/g,
  /v0-runtime/g,
  
  // Cursor patterns
  /@cursor\//g,
  /from ['"]cursor/g,
  /from ['"]@cursor/g,
  /cursor-sdk/g,
  
  // Replit patterns
  /@replit\//g,
  /from ['"]replit/g,
  /replit-runtime/g,
  
  // ============= NEW AI PLATFORMS =============
  
  // Windsurf / Codeium patterns
  /@codeium\//g,
  /from ['"]codeium/g,
  /from ['"]@codeium/g,
  /from ['"]windsurf/g,
  /@windsurf\//g,
  /codeium-/g,
  /windsurf-/g,
  
  // GitHub Copilot patterns
  /@github\/copilot/g,
  /from ['"]@github\/copilot/g,
  /copilot-/g,
  /@copilot\//g,
  
  // Tabnine patterns
  /@tabnine\//g,
  /from ['"]tabnine/g,
  /from ['"]@tabnine/g,
  /tabnine-/g,
  
  // Aider patterns
  /from ['"]aider/g,
  /aider-chat/g,
  /@aider\//g,
  
  // Cline patterns
  /@cline\//g,
  /from ['"]@cline/g,
  /from ['"]cline/g,
  /cline-/g,
  
  // Amazon Q / CodeWhisperer patterns
  /@aws\/codewhisperer/g,
  /from ['"]@aws\/codewhisperer/g,
  /@amazon-q\//g,
  /from ['"]@amazon-q/g,
  /amazon-q-/g,
  /codewhisperer-/g,
  
  // Devin patterns
  /@devin\//g,
  /from ['"]devin/g,
  /from ['"]@cognition/g,
  /@cognition\//g,
  
  // Sourcegraph Cody patterns
  /@sourcegraph\/cody/g,
  /from ['"]@sourcegraph\/cody/g,
  /@cody\//g,
  /cody-agent/g,
  
  // JetBrains AI patterns
  /@jetbrains\/ai/g,
  /from ['"]@jetbrains/g,
  /jetbrains-ai-/g,
  
  // Continue.dev patterns
  /@continue\//g,
  /from ['"]continue/g,
  /continue-/g,
  
  // === EXHAUSTIVE: Supabase integrations path (auto-generated by Lovable) ===
  // NOTE: These are DETECTION patterns only - they get REPLACED during cleaning
  // The cleaning function replaces these with standard @supabase/supabase-js imports
  /@\/integrations\/supabase/g,
  /from ['"]@\/integrations\/supabase/g,
  /from ['"]\.\.\/integrations\/supabase/g,
  /from ['"]\.\.\/\.\.\/integrations\/supabase/g,
  /from ['"]\.\.\/\.\.\/\.\.\/integrations\/supabase/g,
  /integrations\/supabase\/client/g,
  /integrations\/supabase\/types/g,
  
  // === NEW: Relative imports to integrations ===
  /from ['"]\.+\/integrations\//g,
  
  // === NEW: Any lovable-specific hook imports ===
  // NOTE: These get replaced with standard alternatives (sonner, inline hooks)
  /@\/hooks\/use-mobile/g,
  /@\/hooks\/use-toast/g,
  /@\/hooks\/useMobile/g,
  /@\/hooks\/useToast/g,
  /@\/components\/ui\/use-toast/g,
];

export const PROPRIETARY_FILES: string[] = [
  // Lovable / GPT Engineer
  '.bolt',
  '.lovable',
  '.gptengineer',
  '.gpteng',
  'lovable.config',
  'gptengineer.config',
  '.lovable.json',
  '.gptengineer.json',
  'bolt.config',
  '.bolt.json',
  
  // v0 (Vercel)
  '.v0',
  'v0.config',
  '.v0.json',
  'v0-manifest.json',
  
  // Cursor
  '.cursor',
  '.cursorrc',
  'cursor.config',
  '.cursor.json',
  
  // Replit
  '.replit',
  'replit.nix',
  '.replit.json',
  
  // ============= NEW AI PLATFORMS FILES =============
  
  // Windsurf / Codeium
  '.windsurf',
  '.windsurf-rules',
  'windsurf.json',
  'mcp.json',
  '.codeium',
  'codeium.json',
  '.codeiumrc',
  
  // GitHub Copilot
  '.copilot',
  'copilot-instructions.md',
  '.github/copilot',
  '.copilot.yaml',
  '.copilot.yml',
  
  // Tabnine
  '.tabnine',
  'tabnine.toml',
  '.tabnine_config',
  '.tabnine.json',
  
  // Aider
  '.aider.conf.yml',
  '.aider',
  '.aider.input.history',
  '.aider.chat.history.md',
  'CONVENTIONS.md',
  
  // Cline
  '.clinerules',
  'clinerules-bank',
  '.cline',
  '.clinesettings',
  
  // Amazon Q / CodeWhisperer
  '.amazonq',
  '.amazon-q',
  '.codewhisperer',
  'amazonq.json',
  
  // Devin
  '.devin',
  'devin.json',
  '.cognition',
  
  // Sourcegraph Cody
  '.cody',
  'cody.json',
  '.sourcegraph',
  
  // JetBrains AI
  '.idea/aiAssistant',
  '.idea/aiAssistant.xml',
  'jetbrains-ai.json',
  
  // Continue.dev
  '.continue',
  '.continuerc.json',
  
  // === EXHAUSTIVE: Auto-generated Supabase files ===
  'src/integrations/supabase/types.ts',
  'src/integrations/supabase/client.ts',
  'types.ts',
  
  // === NEW: Config files that expose project IDs ===
  'supabase/.temp/',
];

// === EXHAUSTIVE: Paths to completely remove ===
export const PROPRIETARY_PATHS: string[] = [
  'src/integrations/supabase/',
  'src/integrations/',
  '.lovable/',
  '.gptengineer/',
  '.bolt/',
  '.cursor/',
  '.replit/',
  '.v0/',
  'supabase/config.toml',
  'supabase/.temp/',
  '.git/hooks/pre-push',
  
  // ============= NEW AI PLATFORMS PATHS =============
  '.windsurf/',
  '.codeium/',
  '.github/copilot/',
  '.tabnine/',
  '.aider/',
  '.clinerules/',
  'clinerules-bank/',
  '.cline/',
  '.amazonq/',
  '.amazon-q/',
  '.codewhisperer/',
  '.devin/',
  '.cognition/',
  '.cody/',
  '.sourcegraph/',
  '.idea/aiAssistant/',
  '.continue/',
];

// === NEW: Supabase project ID patterns ===
export const SUPABASE_PROJECT_PATTERNS: RegExp[] = [
  // Generic Supabase project ID format (20 lowercase letters)
  /[a-z]{20}\.supabase\.co/g,
  // Specific known project patterns
  /izqveyvcebolrqpqlmho/g,
  // JWT tokens (anon keys, service role keys)
  /eyJ[A-Za-z0-9_-]{100,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g,
];

// === NEW: Exposed API keys patterns ===
export const EXPOSED_KEYS_PATTERNS: RegExp[] = [
  // Stripe live keys
  /sk_live_[A-Za-z0-9]{20,}/g,
  /pk_live_[A-Za-z0-9]{20,}/g,
  // Stripe test keys (also should be cleaned for sovereignty)
  /sk_test_[A-Za-z0-9]{20,}/g,
  /pk_test_[A-Za-z0-9]{20,}/g,
  // Generic API key patterns
  /api[_-]?key['":\s]+['"][A-Za-z0-9_-]{20,}['"]/gi,
  /secret[_-]?key['":\s]+['"][A-Za-z0-9_-]{20,}['"]/gi,
];

export const PROPRIETARY_CONTENT: RegExp[] = [
  // Import statements
  /import\s*{\s*componentTagger\s*}\s*from\s*['"]lovable-tagger['"]\s*;?\n?/g,
  /import\s*.*\s*from\s*['"]@lovable\/[^'"]*['"]\s*;?\n?/g,
  /import\s*.*\s*from\s*['"]@gptengineer\/[^'"]*['"]\s*;?\n?/g,
  /import\s*.*\s*from\s*['"]lovable-[^'"]*['"]\s*;?\n?/g,
  /import\s*.*\s*from\s*['"]@v0\/[^'"]*['"]\s*;?\n?/g,
  /import\s*.*\s*from\s*['"]@bolt\/[^'"]*['"]\s*;?\n?/g,
  /import\s*.*\s*from\s*['"]@cursor\/[^'"]*['"]\s*;?\n?/g,
  
  // === EXHAUSTIVE: Supabase auto-generated imports ===
  /import\s*{\s*supabase\s*}\s*from\s*['"]@\/integrations\/supabase\/client['"]\s*;?\n?/g,
  /import\s*.*\s*from\s*['"]@\/integrations\/supabase\/[^'"]*['"]\s*;?\n?/g,
  /import\s+type\s*{\s*[^}]*\s*}\s*from\s*['"]@\/integrations\/supabase\/types['"]\s*;?\n?/g,
  /import\s*{\s*[^}]+\s*}\s*from\s*['"]@\/integrations\/supabase\/types['"]\s*;?\n?/g,
  
  // Plugin usage in vite.config
  /mode\s*===\s*['"]development['"]\s*&&\s*componentTagger\(\)\s*,?\n?/g,
  /componentTagger\(\)\s*,?\n?/g,
  
  // Comment markers
  /\/\/\s*@lovable.*\n?/g,
  /\/\*\s*@lovable[\s\S]*?\*\//g,
  /\/\/\s*@gptengineer.*\n?/g,
  /\/\*\s*@gptengineer[\s\S]*?\*\//g,
  /\/\/\s*@bolt.*\n?/g,
  /\/\*\s*@bolt[\s\S]*?\*\//g,
  /\/\/\s*@v0.*\n?/g,
  /\/\*\s*@v0[\s\S]*?\*\//g,
  /\/\/\s*Generated by Lovable.*\n?/gi,
  /\/\/\s*Auto-generated.*lovable.*\n?/gi,
  
  // Data attributes
  /data-lovable[^"]*="[^"]*"/g,
  /data-gpt[^"]*="[^"]*"/g,
  /data-bolt[^"]*="[^"]*"/g,
  /data-lov-id="[^"]*"/g,
  /data-lov-component="[^"]*"/g,
  /data-v0[^"]*="[^"]*"/g,
  /data-codeium[^"]*="[^"]*"/g,
  /data-copilot[^"]*="[^"]*"/g,
  /data-tabnine[^"]*="[^"]*"/g,
  /data-cline[^"]*="[^"]*"/g,
  /data-cody[^"]*="[^"]*"/g,
  /data-continue[^"]*="[^"]*"/g,
  
  // Environment variable references
  /VITE_LOVABLE_[A-Z_]+/g,
  /VITE_GPT_[A-Z_]+/g,
  /VITE_CODEIUM_[A-Z_]+/g,
  /VITE_COPILOT_[A-Z_]+/g,
  /VITE_TABNINE_[A-Z_]+/g,
  /VITE_CODY_[A-Z_]+/g,
  
  // ============= GENERIC AI GENERATION COMMENTS =============
  /\/\/\s*@codeium[^\n]*\n?/gi,
  /\/\/\s*@copilot[^\n]*\n?/gi,
  /\/\/\s*@tabnine[^\n]*\n?/gi,
  /\/\/\s*@aider[^\n]*\n?/gi,
  /\/\/\s*@cline[^\n]*\n?/gi,
  /\/\/\s*@amazon-q[^\n]*\n?/gi,
  /\/\/\s*@cody[^\n]*\n?/gi,
  /\/\/\s*@continue[^\n]*\n?/gi,
  /\/\/\s*@devin[^\n]*\n?/gi,
  /\/\/\s*@jetbrains-ai[^\n]*\n?/gi,
  /\/\/\s*Generated by Copilot[^\n]*\n?/gi,
  /\/\/\s*Generated by Codeium[^\n]*\n?/gi,
  /\/\/\s*Generated by Tabnine[^\n]*\n?/gi,
  /\/\/\s*Generated by Cody[^\n]*\n?/gi,
  /\/\/\s*Generated by Continue[^\n]*\n?/gi,
  /\/\/\s*Generated by Devin[^\n]*\n?/gi,
  /\/\/\s*Generated by Amazon Q[^\n]*\n?/gi,
  /\/\/\s*AI-generated[^\n]*\n?/gi,
  /\/\/\s*AI-assisted[^\n]*\n?/gi,
  /\/\/\s*Auto-generated by [A-Za-z]+[^\n]*\n?/gi,
  /\/\*[\s\S]*?AI generated[\s\S]*?\*\//gi,
  /\/\*[\s\S]*?Generated by AI[\s\S]*?\*\//gi,
  
  // === NEW: Hidden telemetry calls ===
  /fetch\s*\(\s*['"][^'"]*lovable[^'"]*['"]/gi,
  /fetch\s*\(\s*['"][^'"]*gptengineer[^'"]*['"]/gi,
  /navigator\.sendBeacon\s*\([^)]*lovable[^)]*\)/gi,
  /navigator\.sendBeacon\s*\([^)]*gptengineer[^)]*\)/gi,
  /new\s+Image\s*\(\s*\)\s*\.src\s*=\s*['"][^'"]*lovable[^'"]*['"]/gi,
  
  // === NEW: WebSocket connections to proprietary servers ===
  /new\s+WebSocket\s*\([^)]*lovable[^)]*\)/gi,
  /new\s+WebSocket\s*\([^)]*gptengineer[^)]*\)/gi,
  /new\s+WebSocket\s*\([^)]*\.supabase\.co[^)]*\)/gi,
  
  // === NEW: Realtime channel subscriptions ===
  /supabase\.channel\s*\(/g,
  /supabase\.removeChannel\s*\(/g,
  /\.on\s*\(\s*['"]postgres_changes['"]/g,
  
  // === NEW: Service worker registrations ===
  /navigator\.serviceWorker\.register\s*\([^)]*lovable[^)]*\)/gi,
];

// === EXHAUSTIVE: Supabase-specific patterns to clean ===
export const SUPABASE_PATTERNS: RegExp[] = [
  // Direct supabase client usage that needs replacement
  /supabase\.from\s*\(/g,
  /supabase\.auth\./g,
  /supabase\.storage\./g,
  /supabase\.functions\.invoke/g,
  /supabase\.rpc\s*\(/g,
  /supabase\.channel\s*\(/g,
  /supabase\.removeChannel/g,
];

// Telemetry DOMAINS (not packages)
export const TELEMETRY_DOMAINS: string[] = [
  // Lovable / GPT Engineer
  'lovable.app',
  'lovable.dev',
  'lovableproject.com', // Added: preview domains
  'events.lovable',
  'telemetry.lovable',
  'gptengineer.app',
  'analytics.lovable',
  'tracking.lovable',
  'api.lovable.dev',
  'ws.lovable.dev',
  'cdn.lovable.dev',
  'cdn.gptengineer.app',
  'assets.lovable',
  'static.lovable',
  'edge.lovable',
  'functions.lovable',
  
  // v0 (Vercel)
  'v0.dev',
  'telemetry.v0.dev',
  'api.v0.dev',
  'cdn.v0.dev',
  
  // Bolt
  'bolt.new',
  'api.bolt.new',
  'cdn.bolt.new',
  
  // Cursor
  'cursor.sh',
  'api.cursor.sh',
  'cursor-telemetry.dev',
  
  // Replit
  'replit.com',
  'api.replit.com',
  'telemetry.replit.com',
  
  // ============= NEW AI PLATFORMS TELEMETRY =============
  
  // Windsurf / Codeium
  'codeium.com',
  'windsurf.ai',
  'api.codeium.com',
  'telemetry.codeium.com',
  'exo.codeium.com',
  'server.codeium.com',
  
  // GitHub Copilot
  'copilot.github.com',
  'githubcopilot.com',
  'api.githubcopilot.com',
  'copilot-telemetry.github.com',
  'default.exp-tas.com',
  'copilot-proxy.githubusercontent.com',
  
  // Tabnine
  'tabnine.com',
  'api.tabnine.com',
  'hub.tabnine.com',
  'update.tabnine.com',
  'telemetry.tabnine.com',
  
  // Aider
  'aider.chat',
  'api.aider.chat',
  
  // Amazon Q / CodeWhisperer
  'codewhisperer.aws.dev',
  'codewhisperer.amazonaws.com',
  'amazon-q.aws',
  'amazonq.aws.dev',
  'q.console.aws.amazon.com',
  
  // Devin
  'devin.ai',
  'cognition.ai',
  'api.cognition.ai',
  'cognition-labs.com',
  
  // Sourcegraph Cody
  'sourcegraph.com',
  'cody.dev',
  'api.cody.dev',
  'telemetry.sourcegraph.com',
  
  // JetBrains AI
  'ai.jetbrains.com',
  'datalore.jetbrains.com',
  'jb.gg',
  
  // Continue.dev
  'continue.dev',
  'api.continue.dev',
  'proxy.continue.dev',
];

// NPM packages to remove
export const SUSPICIOUS_PACKAGES: string[] = [
  // Lovable / GPT Engineer
  'lovable-tagger',
  '@lovable/core',
  '@lovable/cli',
  '@lovable/runtime',
  '@lovable/plugin-react',
  '@gptengineer/core',
  '@gptengineer/cli',
  'gpt-engineer',
  'lovable-analytics',
  'gpt-engineer-tracker',
  
  // Bolt
  'bolt-core',
  '@bolt/core',
  '@bolt/cli',
  '@bolt/runtime',
  
  // v0 (Vercel)
  '@v0/core',
  '@v0/cli',
  '@v0/runtime',
  '@v0/ui',
  'v0-tagger',
  'v0-sdk',
  
  // Cursor
  '@cursor/core',
  '@cursor/sdk',
  'cursor-runtime',
  
  // Replit
  '@replit/core',
  '@replit/extensions',
  'replit-sdk',
  
  // ============= NEW AI PLATFORMS PACKAGES =============
  
  // Windsurf / Codeium
  'codeium',
  '@codeium/core',
  '@codeium/react',
  '@codeium/sdk',
  'windsurf.nvim',
  'windsurf.vim',
  'windsurf-sdk',
  
  // GitHub Copilot
  '@github/copilot',
  'copilot.lua',
  'copilot.vim',
  'copilot-node-server',
  '@copilot/sdk',
  
  // Tabnine
  'tabnine-vscode',
  '@tabnine/core',
  '@tabnine/unity',
  'tabnine-vim',
  'tabnine-nvim',
  
  // Aider
  'aider-chat',
  'aider',
  '@aider/sdk',
  
  // Cline
  '@cline/core',
  '@cline/sdk',
  'cline-ai',
  'cline-vscode',
  
  // Amazon Q / CodeWhisperer
  '@aws/codewhisperer',
  '@aws/amazon-q',
  '@amzn/codewhisperer-streaming',
  'amazon-q-developer',
  
  // Devin
  '@cognition/devin',
  '@devin/sdk',
  'devin-ai',
  
  // Sourcegraph Cody
  '@sourcegraph/cody',
  '@sourcegraph/cody-agent',
  '@sourcegraph/cody-shared',
  'cody-ai',
  
  // JetBrains AI
  '@jetbrains/ai',
  '@jetbrains/ai-assistant',
  'jetbrains-ai',
  
  // Continue.dev
  '@continue/core',
  '@continue/sdk',
  'continue-ai',
];

// Proprietary CDN domains
export const PROPRIETARY_ASSET_CDNS: string[] = [
  'cdn.lovable.app',
  'cdn.lovable.dev',
  'lovableproject.com', // Added: preview domains with assets
  'bolt-assets',
  'assets.bolt.new',
  'cdn.bolt.new',
  'assets.gptengineer.app',
  'cdn.gptengineer.app',
  'storage.lovable.app',
  'storage.lovable.dev',
  'assets.v0.dev',
  'cdn.v0.dev',
  
  // ============= NEW AI PLATFORMS CDNs =============
  'cdn.codeium.com',
  'assets.windsurf.ai',
  'cdn.tabnine.com',
  'assets.devin.ai',
  'cdn.cognition.ai',
  'assets.sourcegraph.com',
  'cdn.continue.dev',
];

// ============= EXTERNAL ASSET URL REPLACEMENTS =============
// Map of external domains to local path replacements
export const EXTERNAL_ASSET_REPLACEMENTS: Record<string, string> = {
  // Lovable project preview domains - replace with local assets
  'lovableproject.com': '/assets',
  'lovable.app': '/assets',
  'lovable.dev': '/assets',
  'cdn.lovable.app': '/assets',
  'cdn.lovable.dev': '/assets',
  'storage.lovable.app': '/assets',
  'storage.lovable.dev': '/assets',
  'gptengineer.app': '/assets',
  'cdn.gptengineer.app': '/assets',
  'assets.gptengineer.app': '/assets',
  // Bolt
  'bolt.new': '/assets',
  'cdn.bolt.new': '/assets',
  'assets.bolt.new': '/assets',
  // v0
  'v0.dev': '/assets',
  'cdn.v0.dev': '/assets',
  'assets.v0.dev': '/assets',
};

/**
 * Clean external asset URLs and replace with local paths
 * Returns the cleaned content and list of assets that need to be downloaded
 */
export function cleanExternalAssetUrls(content: string, filePath: string): {
  cleaned: string;
  changes: string[];
  assetsToDownload: { originalUrl: string; localPath: string }[];
} {
  const changes: string[] = [];
  const assetsToDownload: { originalUrl: string; localPath: string }[] = [];
  let cleaned = content;

  // Pattern to match URLs in various contexts (src="", url(), href="", etc.)
  for (const [domain, localBase] of Object.entries(EXTERNAL_ASSET_REPLACEMENTS)) {
    const escapedDomain = domain.replace(/\./g, '\\.');
    
    // Match full URLs with protocol
    const urlPatterns = [
      // src="https://xxx.lovableproject.com/path/to/image.png"
      new RegExp(`(["'\`])https?://[^"'\`]*${escapedDomain}/([^"'\`]+)(["'\`])`, 'gi'),
      // url(https://xxx.lovableproject.com/path/to/image.png)
      new RegExp(`url\\(\\s*["']?https?://[^)]*${escapedDomain}/([^)]+)["']?\\s*\\)`, 'gi'),
    ];

    for (const pattern of urlPatterns) {
      const matches = cleaned.matchAll(pattern);
      for (const match of matches) {
        const originalUrl = match[0];
        // Extract just the filename/path portion
        const urlMatch = originalUrl.match(/\/([^\/?"'`\s]+(?:\.[a-zA-Z0-9]+))(?:[?"'\s\)]|$)/);
        if (urlMatch) {
          const filename = urlMatch[1];
          const localPath = `${localBase}/${filename}`;
          
          // Only process image/asset files
          if (/\.(png|jpg|jpeg|gif|svg|webp|ico|pdf|mp4|mp3|woff|woff2|ttf|eot)$/i.test(filename)) {
            assetsToDownload.push({ 
              originalUrl: originalUrl.replace(/^["'\`]|["'\`]$/g, '').replace(/^url\(["']?|["']?\)$/g, ''),
              localPath 
            });
          }
        }
      }
    }

    // Replace URLs with local paths
    // Pattern 1: src/href attributes
    const attrPattern = new RegExp(
      `(src|href|poster|srcset)\\s*=\\s*(["'\`])https?://[^"'\`]*${escapedDomain}/[^"'\`]*?([^/"'\`]+\\.[a-zA-Z0-9]+)(["'\`])`,
      'gi'
    );
    const beforeAttr = cleaned;
    cleaned = cleaned.replace(attrPattern, `$1=$2${localBase}/$3$4`);
    if (cleaned !== beforeAttr) {
      changes.push(`URL ${domain} remplacée par chemin local dans attribut`);
    }

    // Pattern 2: CSS url()
    const cssPattern = new RegExp(
      `url\\(\\s*["']?https?://[^)]*${escapedDomain}/[^)]*?([^/)]+\\.[a-zA-Z0-9]+)["']?\\s*\\)`,
      'gi'
    );
    const beforeCss = cleaned;
    cleaned = cleaned.replace(cssPattern, `url('${localBase}/$1')`);
    if (cleaned !== beforeCss) {
      changes.push(`URL ${domain} remplacée par chemin local dans CSS`);
    }

    // Pattern 3: Template strings or JS strings
    const stringPattern = new RegExp(
      `(["'\`])https?://[^"'\`]*${escapedDomain}/[^"'\`]*?([^/"'\`]+\\.[a-zA-Z0-9]+)(["'\`])`,
      'gi'
    );
    const beforeString = cleaned;
    cleaned = cleaned.replace(stringPattern, `$1${localBase}/$2$3`);
    if (cleaned !== beforeString) {
      changes.push(`URL ${domain} remplacée par chemin local dans string`);
    }
  }

  return { cleaned, changes, assetsToDownload };
}

// ============= AUTO-POLYFILL DEFINITIONS =============

export const HOOK_POLYFILLS: Record<string, { filename: string; content: string }> = {
  'use-mobile': {
    filename: 'use-mobile.ts',
    content: `import { useState, useEffect } from 'react';

/**
 * Hook to detect mobile viewport
 * Auto-generated polyfill by Inopay Liberation
 */
export function useIsMobile() {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < 768);
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  return isMobile;
}

export default useIsMobile;`,
  },
  'use-toast': {
    filename: 'use-toast.ts',
    content: `import { useState, useCallback } from 'react';

/**
 * Simple toast notification hook
 * Auto-generated polyfill by Inopay Liberation
 */
export interface Toast {
  id: string;
  title?: string;
  description?: string;
  variant?: 'default' | 'destructive';
}

let toastCount = 0;

export function useToast() {
  const [toasts, setToasts] = useState<Toast[]>([]);

  const toast = useCallback(({ title, description, variant = 'default' }: Omit<Toast, 'id'>) => {
    const id = String(++toastCount);
    const newToast: Toast = { id, title, description, variant };
    setToasts(prev => [...prev, newToast]);
    
    setTimeout(() => {
      setToasts(prev => prev.filter(t => t.id !== id));
    }, 5000);
    
    return { id, dismiss: () => setToasts(prev => prev.filter(t => t.id !== id)) };
  }, []);

  const dismiss = useCallback((id: string) => {
    setToasts(prev => prev.filter(t => t.id !== id));
  }, []);

  return { toast, toasts, dismiss };
}

export default useToast;`,
  },
  'use-sidebar': {
    filename: 'use-sidebar.ts',
    content: `import { useState, useCallback, createContext, useContext } from 'react';

/**
 * Sidebar state management hook
 * Auto-generated polyfill by Inopay Liberation
 */
export interface SidebarState {
  isOpen: boolean;
  toggle: () => void;
  open: () => void;
  close: () => void;
}

const SidebarContext = createContext<SidebarState | null>(null);

export function useSidebar(): SidebarState {
  const context = useContext(SidebarContext);
  const [isOpen, setIsOpen] = useState(true);
  
  if (context) return context;
  
  return {
    isOpen,
    toggle: () => setIsOpen(prev => !prev),
    open: () => setIsOpen(true),
    close: () => setIsOpen(false),
  };
}

export { SidebarContext };
export default useSidebar;`,
  },
  'supabase-client': {
    filename: 'supabase-client.ts',
    content: `import { createClient } from '@supabase/supabase-js';

/**
 * Supabase client configuration
 * Auto-generated by Inopay Liberation - Configure your own Supabase project
 */

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  console.warn('Missing Supabase environment variables. Please configure VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY');
}

export const supabase = createClient(
  supabaseUrl || 'https://your-project.supabase.co',
  supabaseAnonKey || 'your-anon-key',
  {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
    },
  }
);

export default supabase;`,
  },
  'use-auth': {
    filename: 'use-auth.ts',
    content: `import { useState, useEffect, createContext, useContext, ReactNode } from 'react';
import { supabase } from './supabase-client';
import type { User, Session } from '@supabase/supabase-js';

/**
 * Authentication hook
 * Auto-generated polyfill by Inopay Liberation
 */
export interface AuthContextType {
  user: User | null;
  session: Session | null;
  loading: boolean;
  signIn: (email: string, password: string) => Promise<void>;
  signUp: (email: string, password: string) => Promise<void>;
  signOut: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | null>(null);

export function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  const [user, setUser] = useState<User | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setUser(session?.user ?? null);
      setLoading(false);
    });

    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (_event, session) => {
        setSession(session);
        setUser(session?.user ?? null);
      }
    );

    return () => subscription.unsubscribe();
  }, []);

  if (context) return context;

  return {
    user,
    session,
    loading,
    signIn: async (email, password) => {
      const { error } = await supabase.auth.signInWithPassword({ email, password });
      if (error) throw error;
    },
    signUp: async (email, password) => {
      const { error } = await supabase.auth.signUp({ email, password });
      if (error) throw error;
    },
    signOut: async () => {
      const { error } = await supabase.auth.signOut();
      if (error) throw error;
    },
  };
}

export { AuthContext };
export default useAuth;`,
  },
};

// ============= UTILITY FUNCTIONS =============

/**
 * Check if file should be completely removed
 */
export function shouldRemoveFile(filePath: string): boolean {
  const fileName = filePath.split('/').pop() || '';
  
  // Check exact file matches
  for (const pattern of PROPRIETARY_FILES) {
    if (fileName === pattern || filePath.includes(`/${pattern}`) || filePath.endsWith(pattern)) {
      return true;
    }
  }
  
  // Check path patterns
  for (const pathPattern of PROPRIETARY_PATHS) {
    if (filePath.includes(pathPattern)) {
      return true;
    }
  }
  
  // NEW: Remove any file in integrations folder
  if (filePath.includes('/integrations/')) {
    return true;
  }
  
  return false;
}

/**
 * Check if content contains proprietary patterns (basic check)
 */
export function needsCleaning(content: string): boolean {
  // Check proprietary imports
  for (const pattern of PROPRIETARY_IMPORTS) {
    const regex = new RegExp(pattern.source, pattern.flags);
    if (regex.test(content)) return true;
  }
  
  // Check for telemetry domains
  for (const domain of TELEMETRY_DOMAINS) {
    if (content.includes(domain)) return true;
  }
  
  // Check for suspicious packages in package.json
  if (content.includes('"dependencies"') || content.includes('"devDependencies"')) {
    for (const pkg of SUSPICIOUS_PACKAGES) {
      if (content.includes(`"${pkg}"`)) return true;
    }
  }
  
  // Check for @/integrations path
  if (content.includes('@/integrations/supabase')) return true;
  if (content.includes('integrations/supabase')) return true;
  
  // NEW: Check for hardcoded Supabase project IDs
  for (const pattern of SUPABASE_PROJECT_PATTERNS) {
    if (pattern.test(content)) return true;
  }
  
  return false;
}

/**
 * DEEP CLEAN V3: Maximum sovereignty cleaning with multiple passes
 * This function cleans ALL source files systematically with exhaustive checks
 */
export function deepCleanSourceFile(content: string, filePath: string): { 
  cleaned: string; 
  changes: string[]; 
  wasModified: boolean;
  suspiciousPatterns: string[];
} {
  const changes: string[] = [];
  const suspiciousPatterns: string[] = [];
  let cleaned = content;
  const originalContent = content;

  // ========== PASS 1: Remove ALL proprietary import statements ==========
  const importPatterns = [
    // Lovable/GPT Engineer imports
    { pattern: /import\s*{\s*componentTagger\s*}\s*from\s*['"]lovable-tagger['"]\s*;?\n?/g, name: 'lovable-tagger import' },
    { pattern: /import\s*[^;]*\s*from\s*['"]@lovable\/[^'"]*['"]\s*;?\n?/g, name: '@lovable import' },
    { pattern: /import\s*[^;]*\s*from\s*['"]@gptengineer\/[^'"]*['"]\s*;?\n?/g, name: '@gptengineer import' },
    { pattern: /import\s*[^;]*\s*from\s*['"]lovable-[^'"]*['"]\s*;?\n?/g, name: 'lovable- import' },
    { pattern: /import\s*[^;]*\s*from\s*['"]@v0\/[^'"]*['"]\s*;?\n?/g, name: '@v0 import' },
    { pattern: /import\s*[^;]*\s*from\s*['"]@bolt\/[^'"]*['"]\s*;?\n?/g, name: '@bolt import' },
    { pattern: /import\s*[^;]*\s*from\s*['"]@cursor\/[^'"]*['"]\s*;?\n?/g, name: '@cursor import' },
    { pattern: /import\s*[^;]*\s*from\s*['"]@replit\/[^'"]*['"]\s*;?\n?/g, name: '@replit import' },
  ];

  for (const { pattern, name } of importPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, '');
    if (cleaned !== before) {
      changes.push(`Import propriétaire supprimé: ${name}`);
    }
  }

  // ========== PASS 2: Replace @/integrations/supabase with CENTRALIZED POLYFILLS ==========
  // CRITICAL FIX V2: Use centralized polyfill paths instead of inline code injection
  // This prevents duplicate declarations and syntax errors
  
  // Replace supabase client imports with polyfill path
  const supabaseClientPatterns = [
    /import\s*{\s*supabase\s*}\s*from\s*['"]@\/integrations\/supabase\/client['"]\s*;?/g,
    /import\s+{\s*supabase\s*}\s+from\s+['"]@\/integrations\/supabase\/client['"]\s*;?/g,
  ];
  
  for (const pattern of supabaseClientPatterns) {
    const beforeClient = cleaned;
    cleaned = cleaned.replace(pattern, "import { supabase } from '@/lib/supabase';");
    if (cleaned !== beforeClient) {
      changes.push('Import supabase redirigé vers @/lib/supabase');
    }
  }
  
  // Replace type imports with polyfill path - PRESERVE EXACT TYPE NAMES
  const supabaseTypesPattern = /import\s+type\s*{\s*([^}]+)\s*}\s*from\s*['"]@\/integrations\/supabase\/types['"]\s*;?/g;
  const before1 = cleaned;
  cleaned = cleaned.replace(supabaseTypesPattern, "import type { $1 } from '@/types/database';");
  if (cleaned !== before1) {
    changes.push('Types Supabase redirigés vers @/types/database');
  }
  
  // Replace regular type imports (Database, Tables, etc.)
  const supabaseTypesPattern2 = /import\s*{\s*([^}]*(?:Database|Tables|TablesInsert|TablesUpdate|Json)[^}]*)\s*}\s*from\s*['"]@\/integrations\/supabase\/types['"]\s*;?/g;
  const before2 = cleaned;
  cleaned = cleaned.replace(supabaseTypesPattern2, "import type { $1 } from '@/types/database';");
  if (cleaned !== before2) {
    changes.push('Types Database redirigés vers @/types/database');
  }
  
  // Catch any remaining @/integrations/supabase patterns
  const remainingIntegrationsClient = /from\s*['"]@\/integrations\/supabase\/client['"]/g;
  const before3a = cleaned;
  cleaned = cleaned.replace(remainingIntegrationsClient, "from '@/lib/supabase'");
  if (cleaned !== before3a) {
    changes.push('Imports client @/integrations restants corrigés');
  }
  
  const remainingIntegrationsTypes = /from\s*['"]@\/integrations\/supabase\/types['"]/g;
  const before3b = cleaned;
  cleaned = cleaned.replace(remainingIntegrationsTypes, "from '@/types/database'");
  if (cleaned !== before3b) {
    changes.push('Imports types @/integrations restants corrigés');
  }
  
  // Handle relative paths to integrations
  const relativeIntegrationsClient = /from\s*['"]\.+\/integrations\/supabase\/client['"]/g;
  const before4a = cleaned;
  cleaned = cleaned.replace(relativeIntegrationsClient, "from '@/lib/supabase'");
  if (cleaned !== before4a) {
    changes.push('Imports relatifs client corrigés');
  }
  
  const relativeIntegrationsTypes = /from\s*['"]\.+\/integrations\/supabase\/types['"]/g;
  const before4b = cleaned;
  cleaned = cleaned.replace(relativeIntegrationsTypes, "from '@/types/database'");
  if (cleaned !== before4b) {
    changes.push('Imports relatifs types corrigés');
  }
  
  // ========== PASS 2b: Replace @/hooks/use-toast with sonner ==========
  const useToastPatterns = [
    /import\s*{\s*(?:useToast|toast|useToast,\s*toast|toast,\s*useToast)\s*}\s*from\s*['"]@\/hooks\/use-toast['"]\s*;?/g,
    /import\s*{\s*(?:useToast|toast|useToast,\s*toast|toast,\s*useToast)\s*}\s*from\s*['"]@\/components\/ui\/use-toast['"]\s*;?/g,
  ];
  
  for (const pattern of useToastPatterns) {
    const before5 = cleaned;
    cleaned = cleaned.replace(pattern, "import { toast } from 'sonner';");
    if (cleaned !== before5) {
      changes.push('useToast remplacé par sonner');
    }
  }
  
  // Remove const { toast } = useToast() pattern since we import toast directly
  const useToastDestructure = /const\s*{\s*toast\s*}\s*=\s*useToast\s*\(\s*\)\s*;?\n?/g;
  const before7 = cleaned;
  cleaned = cleaned.replace(useToastDestructure, '');
  if (cleaned !== before7) {
    changes.push('Destructuration useToast supprimée');
  }
  
  // ========== PASS 2c: Replace @/hooks/use-mobile with polyfill path ==========
  // Instead of injecting inline code, redirect to centralized polyfill
  const useMobileImportPattern = /import\s*{\s*useIsMobile\s*}\s*from\s*['"]@\/hooks\/use-mobile['"]\s*;?/g;
  const before8 = cleaned;
  cleaned = cleaned.replace(useMobileImportPattern, "import { useIsMobile } from '@/hooks/use-mobile';");
  if (cleaned !== before8) {
    // No change needed - keep original path, polyfill will be generated
    changes.push('useIsMobile conservé (polyfill sera généré)');
  }

  // ========== PASS 3: Remove ALL proprietary content patterns ==========
  const contentPatterns = [
    // Plugin usage in vite.config
    { pattern: /mode\s*===\s*['"]development['"]\s*&&\s*componentTagger\(\)\s*,?\n?/g, name: 'componentTagger plugin' },
    { pattern: /componentTagger\(\)\s*,?\n?/g, name: 'componentTagger call' },
    // Comment markers
    { pattern: /\/\/\s*@lovable[^\n]*\n?/gi, name: '@lovable comment' },
    { pattern: /\/\*\s*@lovable[\s\S]*?\*\//g, name: '@lovable block comment' },
    { pattern: /\/\/\s*@gptengineer[^\n]*\n?/gi, name: '@gptengineer comment' },
    { pattern: /\/\*\s*@gptengineer[\s\S]*?\*\//g, name: '@gptengineer block comment' },
    { pattern: /\/\/\s*@bolt[^\n]*\n?/gi, name: '@bolt comment' },
    { pattern: /\/\/\s*@v0[^\n]*\n?/gi, name: '@v0 comment' },
    { pattern: /\/\/\s*Generated by Lovable[^\n]*\n?/gi, name: 'Generated by Lovable' },
    { pattern: /\/\/\s*Auto-generated[^\n]*lovable[^\n]*\n?/gi, name: 'Auto-generated lovable' },
    { pattern: /\/\/\s*Built with Lovable[^\n]*\n?/gi, name: 'Built with Lovable' },
    { pattern: /\/\*[\s\S]*?lovable[\s\S]*?\*\//gi, name: 'lovable block comment' },
    // Data attributes
    { pattern: /\s*data-lovable[^=]*="[^"]*"/g, name: 'data-lovable attr' },
    { pattern: /\s*data-lov-[^=]*="[^"]*"/g, name: 'data-lov attr' },
    { pattern: /\s*data-gpt[^=]*="[^"]*"/g, name: 'data-gpt attr' },
    { pattern: /\s*data-bolt[^=]*="[^"]*"/g, name: 'data-bolt attr' },
    { pattern: /\s*data-v0[^=]*="[^"]*"/g, name: 'data-v0 attr' },
  ];

  for (const { pattern, name } of contentPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, '');
    if (cleaned !== before) {
      changes.push(`Pattern nettoyé: ${name}`);
    }
  }

  // ========== PASS 4: Remove telemetry domain references ==========
  for (const domain of TELEMETRY_DOMAINS) {
    const escapedDomain = domain.replace(/\./g, '\\.');
    const domainPattern = new RegExp(`['"\`][^'"\`]*${escapedDomain}[^'"\`]*['"\`]`, 'gi');
    const before = cleaned;
    cleaned = cleaned.replace(domainPattern, '""');
    if (cleaned !== before) {
      changes.push(`Télémétrie supprimée: ${domain}`);
    }
  }

  // ========== PASS 5: Clean hardcoded Supabase project IDs ==========
  const supabaseIdPatterns = [
    { pattern: /[a-z]{20}\.supabase\.co/g, replacement: 'your-project.supabase.co', name: 'Supabase project URL' },
    { pattern: /eyJ[A-Za-z0-9_-]{100,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g, replacement: 'YOUR_SUPABASE_KEY', name: 'JWT token' },
  ];

  for (const { pattern, replacement, name } of supabaseIdPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, replacement);
    if (cleaned !== before) {
      changes.push(`ID remplacé: ${name}`);
    }
  }

  // ========== PASS 6: Remove exposed API keys ==========
  const keyPatterns = [
    { pattern: /sk_live_[A-Za-z0-9]{20,}/g, replacement: 'sk_live_YOUR_KEY', name: 'Stripe live secret key' },
    { pattern: /pk_live_[A-Za-z0-9]{20,}/g, replacement: 'pk_live_YOUR_KEY', name: 'Stripe live public key' },
    { pattern: /sk_test_[A-Za-z0-9]{20,}/g, replacement: 'sk_test_YOUR_KEY', name: 'Stripe test secret key' },
    { pattern: /pk_test_[A-Za-z0-9]{20,}/g, replacement: 'pk_test_YOUR_KEY', name: 'Stripe test public key' },
  ];

  for (const { pattern, replacement, name } of keyPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, replacement);
    if (cleaned !== before) {
      suspiciousPatterns.push(`Clé exposée détectée dans ${filePath}: ${name}`);
      changes.push(`Clé nettoyée: ${name}`);
    }
  }

  // ========== PASS 7: Remove data-* attributes specific to platforms ==========
  const dataAttrPatterns = [
    /\s*data-lovable[^=]*="[^"]*"/g,
    /\s*data-lov-[^=]*="[^"]*"/g,
    /\s*data-gpt[^=]*="[^"]*"/g,
    /\s*data-bolt[^=]*="[^"]*"/g,
    /\s*data-v0[^=]*="[^"]*"/g,
    /\s*data-cursor[^=]*="[^"]*"/g,
    /\s*data-replit[^=]*="[^"]*"/g,
  ];

  for (const pattern of dataAttrPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, '');
    if (cleaned !== before) {
      changes.push('Attributs data-* supprimés');
    }
  }

  // ========== PASS 8: Detect and remove hidden telemetry ==========
  const hiddenTelemetryPatterns = [
    { pattern: /fetch\s*\([^)]*lovable[^)]*\)/gi, name: 'fetch lovable' },
    { pattern: /fetch\s*\([^)]*gptengineer[^)]*\)/gi, name: 'fetch gptengineer' },
    { pattern: /navigator\.sendBeacon\s*\([^)]*lovable[^)]*\)/gi, name: 'sendBeacon lovable' },
    { pattern: /navigator\.sendBeacon\s*\([^)]*gptengineer[^)]*\)/gi, name: 'sendBeacon gptengineer' },
    { pattern: /new\s+WebSocket\s*\([^)]*lovable[^)]*\)/gi, name: 'WebSocket lovable' },
    { pattern: /new\s+WebSocket\s*\([^)]*gptengineer[^)]*\)/gi, name: 'WebSocket gptengineer' },
  ];

  for (const { pattern, name } of hiddenTelemetryPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, '/* REMOVED: telemetry */');
    if (cleaned !== before) {
      suspiciousPatterns.push(`Appel suspect supprimé: ${name}`);
      changes.push(`Télémétrie supprimée: ${name}`);
    }
  }

  // ========== PASS 9: Remove VITE_ env vars that are proprietary ==========
  const envVarPatterns = [
    { pattern: /import\.meta\.env\.VITE_LOVABLE_[A-Z_]+/g, name: 'VITE_LOVABLE_*' },
    { pattern: /import\.meta\.env\.VITE_GPT_[A-Z_]+/g, name: 'VITE_GPT_*' },
    { pattern: /process\.env\.VITE_LOVABLE_[A-Z_]+/g, name: 'process.env VITE_LOVABLE_*' },
    { pattern: /process\.env\.VITE_GPT_[A-Z_]+/g, name: 'process.env VITE_GPT_*' },
  ];

  for (const { pattern, name } of envVarPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, '""');
    if (cleaned !== before) {
      changes.push(`Variable env supprimée: ${name}`);
    }
  }

  // ========== PASS 10: Remove proprietary comments (comprehensive) ==========
  const commentPatterns = [
    { pattern: /\/\/\s*@lovable[^\n]*\n?/gi, name: '@lovable comment' },
    { pattern: /\/\/\s*@gptengineer[^\n]*\n?/gi, name: '@gptengineer comment' },
    { pattern: /\/\/\s*Generated by Lovable[^\n]*\n?/gi, name: 'Generated by Lovable' },
    { pattern: /\/\/\s*Built with Lovable[^\n]*\n?/gi, name: 'Built with Lovable' },
    { pattern: /\/\/\s*Created with GPT Engineer[^\n]*\n?/gi, name: 'Created with GPT Engineer' },
    { pattern: /\/\*\s*@lovable[\s\S]*?\*\//gi, name: '@lovable block' },
    { pattern: /\/\*\s*@gptengineer[\s\S]*?\*\//gi, name: '@gptengineer block' },
    { pattern: /<!--[\s\S]*?lovable[\s\S]*?-->/gi, name: 'lovable HTML comment' },
    { pattern: /<!--[\s\S]*?gptengineer[\s\S]*?-->/gi, name: 'gptengineer HTML comment' },
  ];

  for (const { pattern, name } of commentPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, '');
    if (cleaned !== before) {
      changes.push(`Commentaire supprimé: ${name}`);
    }
  }

  // ========== PASS 11: Clean external asset URLs (lovableproject.com, etc.) ==========
  const assetCleanResult = cleanExternalAssetUrls(cleaned, filePath);
  if (assetCleanResult.changes.length > 0) {
    cleaned = assetCleanResult.cleaned;
    changes.push(...assetCleanResult.changes);
    if (assetCleanResult.assetsToDownload.length > 0) {
      suspiciousPatterns.push(`${assetCleanResult.assetsToDownload.length} assets externes à télécharger localement`);
    }
  }

  // ========== PASS 12: Replace proprietary AI services with open-source alternatives ==========
  // OpenAI → Ollama
  if (/import\s+OpenAI\s+from\s*['"]openai['"];?/.test(cleaned)) {
    cleaned = cleaned.replace(/import\s+OpenAI\s+from\s*['"]openai['"];?/g, 
      `// INOPAY: OpenAI remplacé par Ollama (auto-hébergé)
const OLLAMA_BASE_URL = import.meta.env.VITE_OLLAMA_URL || 'http://localhost:11434';

async function createChatCompletion(messages: Array<{role: string; content: string}>, model = 'llama3.1') {
  const response = await fetch(\`\${OLLAMA_BASE_URL}/api/chat\`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model, messages, stream: false })
  });
  return response.json();
}`);
    changes.push('OpenAI remplacé par Ollama (auto-hébergé)');
  }
  
  // Replace new OpenAI({ ... }) instantiation
  if (/new\s+OpenAI\s*\(\s*\{[^}]*\}\s*\)/.test(cleaned)) {
    cleaned = cleaned.replace(/new\s+OpenAI\s*\(\s*\{[^}]*\}\s*\)/g, '/* INOPAY: Ollama client - voir createChatCompletion() */');
    changes.push('Instanciation OpenAI supprimée');
  }
  
  // Replace openai.chat.completions.create calls
  if (/openai\.chat\.completions\.create\s*\(/.test(cleaned)) {
    cleaned = cleaned.replace(/openai\.chat\.completions\.create\s*\(/g, 'createChatCompletion(');
    changes.push('Appels OpenAI remplacés par Ollama');
  }
  
  // Anthropic → Ollama + Llama 3.1
  if (/import\s+Anthropic\s+from\s*['"]@anthropic-ai\/sdk['"];?/.test(cleaned)) {
    cleaned = cleaned.replace(/import\s+Anthropic\s+from\s*['"]@anthropic-ai\/sdk['"];?/g,
      `// INOPAY: Anthropic (Claude) remplacé par Ollama + Llama 3.1 (auto-hébergé)
const OLLAMA_BASE_URL = import.meta.env.VITE_OLLAMA_URL || 'http://localhost:11434';

async function createMessage(messages: Array<{role: string; content: string}>, model = 'llama3.1:70b') {
  const response = await fetch(\`\${OLLAMA_BASE_URL}/api/chat\`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model, messages, stream: false })
  });
  const data = await response.json();
  return { content: [{ text: data.message?.content || '' }] };
}`);
    changes.push('Anthropic (Claude) remplacé par Ollama + Llama 3.1');
  }
  
  // Replace new Anthropic({ ... }) instantiation
  if (/new\s+Anthropic\s*\(\s*\{[^}]*\}\s*\)/.test(cleaned)) {
    cleaned = cleaned.replace(/new\s+Anthropic\s*\(\s*\{[^}]*\}\s*\)/g, '/* INOPAY: Ollama client - voir createMessage() */');
    changes.push('Instanciation Anthropic supprimée');
  }
  
  // Replace anthropic.messages.create calls
  if (/anthropic\.messages\.create\s*\(/.test(cleaned)) {
    cleaned = cleaned.replace(/anthropic\.messages\.create\s*\(/g, 'createMessage(');
    changes.push('Appels Anthropic remplacés par Ollama');
  }
  
  // Pinecone → pgvector (TODO comment)
  if (/import\s*{\s*[^}]*\s*}\s*from\s*['"]@pinecone-database\/pinecone['"];?/.test(cleaned)) {
    cleaned = cleaned.replace(/import\s*{\s*[^}]*\s*}\s*from\s*['"]@pinecone-database\/pinecone['"];?/g,
      `// INOPAY: TODO - Remplacer Pinecone par PostgreSQL + pgvector
// Installation: CREATE EXTENSION vector;
// Usage: SELECT * FROM items ORDER BY embedding <=> $1 LIMIT 10;
// Voir: https://github.com/pgvector/pgvector`);
    changes.push('Pinecone → pgvector (TODO)');
  }
  
  // Clerk → Supabase Auth
  if (/import\s*{\s*([^}]*)\s*}\s*from\s*['"]@clerk\/react['"];?/.test(cleaned)) {
    cleaned = cleaned.replace(/import\s*{\s*([^}]*)\s*}\s*from\s*['"]@clerk\/react['"];?/g,
      `// INOPAY: Clerk remplacé par Supabase Auth (auto-hébergé)
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  import.meta.env.VITE_SUPABASE_URL,
  import.meta.env.VITE_SUPABASE_ANON_KEY
);

// Migration Clerk → Supabase Auth:
// useUser() → supabase.auth.getUser()
// SignIn → supabase.auth.signInWithPassword({ email, password })
// SignUp → supabase.auth.signUp({ email, password })
// SignOut → supabase.auth.signOut()`);
    changes.push('Clerk remplacé par Supabase Auth');
  }
  
  // Auth0 → Supabase Auth
  if (/import\s*{\s*([^}]*)\s*}\s*from\s*['"]@auth0\/auth0-react['"];?/.test(cleaned)) {
    cleaned = cleaned.replace(/import\s*{\s*([^}]*)\s*}\s*from\s*['"]@auth0\/auth0-react['"];?/g,
      `// INOPAY: Auth0 remplacé par Supabase Auth (auto-hébergé)
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  import.meta.env.VITE_SUPABASE_URL,
  import.meta.env.VITE_SUPABASE_ANON_KEY
);

// Migration Auth0 → Supabase Auth:
// useAuth0() → supabase.auth
// loginWithRedirect() → supabase.auth.signInWithOAuth()
// logout() → supabase.auth.signOut()`);
    changes.push('Auth0 remplacé par Supabase Auth');
  }
  
  // Algolia → Meilisearch
  if (/import\s+algoliasearch\s+from\s*['"]algoliasearch['"];?/.test(cleaned)) {
    cleaned = cleaned.replace(/import\s+algoliasearch\s+from\s*['"]algoliasearch['"];?/g,
      `// INOPAY: Algolia remplacé par Meilisearch (auto-hébergé)
import { MeiliSearch } from 'meilisearch';

const searchClient = new MeiliSearch({
  host: import.meta.env.VITE_MEILISEARCH_URL || 'http://localhost:7700',
  apiKey: import.meta.env.VITE_MEILISEARCH_KEY || ''
});`);
    changes.push('Algolia remplacé par Meilisearch');
  }

  // ========== PASS 13: Replace cloud services with self-hosted alternatives ==========
  
  // Firebase → PocketBase
  const firebaseAppPattern = /import\s*{\s*initializeApp\s*}\s*from\s*['"]firebase\/app['"];?/g;
  if (firebaseAppPattern.test(cleaned)) {
    cleaned = cleaned.replace(firebaseAppPattern,
      `// INOPAY: Firebase remplacé par PocketBase (auto-hébergé)
import PocketBase from 'pocketbase';

const pb = new PocketBase(import.meta.env.VITE_POCKETBASE_URL || 'http://localhost:8090');`);
    changes.push('Firebase App remplacé par PocketBase');
  }
  
  // Firebase Auth
  const firebaseAuthPattern = /import\s*{\s*([^}]*)\s*}\s*from\s*['"]firebase\/auth['"];?/g;
  if (firebaseAuthPattern.test(cleaned)) {
    cleaned = cleaned.replace(firebaseAuthPattern,
      `// INOPAY: Firebase Auth remplacé par PocketBase Auth
// Migration:
// signInWithEmailAndPassword → pb.collection('users').authWithPassword(email, password)
// createUserWithEmailAndPassword → pb.collection('users').create({ email, password })
// signOut → pb.authStore.clear()`);
    changes.push('Firebase Auth remplacé par PocketBase Auth');
  }
  
  // Firebase Firestore
  const firestorePattern = /import\s*{\s*([^}]*)\s*}\s*from\s*['"]firebase\/firestore['"];?/g;
  if (firestorePattern.test(cleaned)) {
    cleaned = cleaned.replace(firestorePattern,
      `// INOPAY: Firestore remplacé par PocketBase Collections
// Migration:
// collection(db, 'users') → pb.collection('users')
// addDoc → pb.collection('x').create(data)
// getDocs → pb.collection('x').getList()
// doc + updateDoc → pb.collection('x').update(id, data)
// doc + deleteDoc → pb.collection('x').delete(id)`);
    changes.push('Firestore remplacé par PocketBase Collections');
  }
  
  // Firebase Storage
  const firebaseStoragePattern = /import\s*{\s*([^}]*)\s*}\s*from\s*['"]firebase\/storage['"];?/g;
  if (firebaseStoragePattern.test(cleaned)) {
    cleaned = cleaned.replace(firebaseStoragePattern,
      `// INOPAY: Firebase Storage remplacé par MinIO
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';

const s3 = new S3Client({
  endpoint: import.meta.env.VITE_MINIO_ENDPOINT || 'http://localhost:9000',
  region: 'us-east-1',
  credentials: {
    accessKeyId: import.meta.env.VITE_MINIO_ACCESS_KEY || 'minioadmin',
    secretAccessKey: import.meta.env.VITE_MINIO_SECRET_KEY || 'minioadmin',
  },
  forcePathStyle: true,
});`);
    changes.push('Firebase Storage remplacé par MinIO');
  }
  
  // AWS Lambda references → Docker containers
  const lambdaPattern = /import\s*{\s*([^}]*LambdaClient[^}]*)\s*}\s*from\s*['"]@aws-sdk\/client-lambda['"];?/g;
  if (lambdaPattern.test(cleaned)) {
    cleaned = cleaned.replace(lambdaPattern,
      `// INOPAY: AWS Lambda remplacé par Docker containers
// Déployez vos fonctions comme containers Docker:
// 1. Créer un Dockerfile pour chaque fonction
// 2. Déployer sur votre VPS avec Docker Compose
// 3. Exposer via un reverse proxy (Caddy/Nginx)
// Voir: docker-compose.yml généré par Inopay`);
    changes.push('AWS Lambda → Docker containers (TODO)');
  }
  
  // AWS S3 → MinIO
  const s3Pattern = /import\s*{\s*([^}]*S3Client[^}]*)\s*}\s*from\s*['"]@aws-sdk\/client-s3['"];?/g;
  const s3Match = cleaned.match(s3Pattern);
  if (s3Match && !cleaned.includes('VITE_MINIO_ENDPOINT')) {
    // Add MinIO configuration comment
    cleaned = cleaned.replace(s3Pattern,
      `// INOPAY: S3 → MinIO (compatible S3)
// Configurez le endpoint vers MinIO:
import { $1 } from '@aws-sdk/client-s3';

// Ajoutez ces options au client S3:
// endpoint: import.meta.env.VITE_MINIO_ENDPOINT || 'http://localhost:9000',
// forcePathStyle: true,`);
    changes.push('AWS S3 → MinIO (configuration)');
  }
  
  // Pusher → Soketi
  const pusherPattern = /new\s+Pusher\s*\(\s*['"][^'"]+['"]\s*,\s*\{([^}]*)\}\s*\)/g;
  if (pusherPattern.test(cleaned)) {
    cleaned = cleaned.replace(pusherPattern,
      `new Pusher(import.meta.env.VITE_PUSHER_KEY || 'app-key', {
  wsHost: import.meta.env.VITE_SOKETI_HOST || 'localhost',
  wsPort: parseInt(import.meta.env.VITE_SOKETI_PORT || '6001'),
  forceTLS: false,
  disableStats: true,
  enabledTransports: ['ws', 'wss'],
  cluster: 'mt1' // INOPAY: Soketi - Pusher auto-hébergé
})`);
    changes.push('Pusher configuré pour Soketi');
  }
  
  // SendGrid → Nodemailer
  const sendgridPattern = /import\s+sgMail\s+from\s*['"]@sendgrid\/mail['"];?/g;
  if (sendgridPattern.test(cleaned)) {
    cleaned = cleaned.replace(sendgridPattern,
      `// INOPAY: SendGrid remplacé par Nodemailer SMTP
import nodemailer from 'nodemailer';

const transporter = nodemailer.createTransport({
  host: import.meta.env.SMTP_HOST || 'localhost',
  port: parseInt(import.meta.env.SMTP_PORT || '587'),
  secure: false,
  auth: {
    user: import.meta.env.SMTP_USER,
    pass: import.meta.env.SMTP_PASS,
  },
});

// Usage: await transporter.sendMail({ from, to, subject, html })`);
    changes.push('SendGrid remplacé par Nodemailer SMTP');
  }
  
  // Resend → Nodemailer
  const resendPattern = /import\s*{\s*Resend\s*}\s*from\s*['"]resend['"];?/g;
  if (resendPattern.test(cleaned)) {
    cleaned = cleaned.replace(resendPattern,
      `// INOPAY: Resend remplacé par Nodemailer SMTP
import nodemailer from 'nodemailer';

const transporter = nodemailer.createTransport({
  host: import.meta.env.SMTP_HOST || 'localhost',
  port: parseInt(import.meta.env.SMTP_PORT || '587'),
  secure: false,
  auth: {
    user: import.meta.env.SMTP_USER,
    pass: import.meta.env.SMTP_PASS,
  },
});`);
    changes.push('Resend remplacé par Nodemailer SMTP');
  }
  
  // Cloudinary → MinIO + Sharp
  const cloudinaryPattern = /import\s*{\s*v2\s+as\s+cloudinary\s*}\s*from\s*['"]cloudinary['"];?/g;
  if (cloudinaryPattern.test(cleaned)) {
    cleaned = cleaned.replace(cloudinaryPattern,
      `// INOPAY: Cloudinary remplacé par MinIO + Sharp
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import sharp from 'sharp';

const s3 = new S3Client({
  endpoint: import.meta.env.VITE_MINIO_ENDPOINT || 'http://localhost:9000',
  region: 'us-east-1',
  credentials: {
    accessKeyId: import.meta.env.VITE_MINIO_ACCESS_KEY || '',
    secretAccessKey: import.meta.env.VITE_MINIO_SECRET_KEY || '',
  },
  forcePathStyle: true,
});

// Pour les transformations d'images, utilisez Sharp côté serveur:
// const optimized = await sharp(buffer).resize(800).webp().toBuffer();`);
    changes.push('Cloudinary remplacé par MinIO + Sharp');
  }
  
  // Stripe → (note: keep but add self-hosted alternative note)
  const stripePattern = /import\s+Stripe\s+from\s*['"]stripe['"];?/g;
  if (stripePattern.test(cleaned)) {
    // Don't replace Stripe but add a comment about alternatives
    cleaned = cleaned.replace(stripePattern,
      `import Stripe from 'stripe';
// INOPAY: Stripe conservé - Alternatives auto-hébergées possibles:
// - BTCPay Server (Bitcoin/Lightning)
// - Kill Bill (facturation open-source)
// - LemonSqueezy (moins de frais)`);
    changes.push('Note ajoutée: alternatives à Stripe');
  }
  
  // Twilio → Plivo/VoIP self-hosted
  const twilioPattern = /import\s+twilio\s+from\s*['"]twilio['"];?/g;
  if (twilioPattern.test(cleaned)) {
    cleaned = cleaned.replace(twilioPattern,
      `// INOPAY: Twilio - considérez des alternatives
// Alternatives auto-hébergées:
// - FreeSWITCH pour VoIP
// - Plivo (moins cher)
// - SMS via passerelle SMTP-to-SMS
import twilio from 'twilio'; // Conservé car pas d'alternative directe simple`);
    changes.push('Note ajoutée: alternatives à Twilio');
  }

  // ========== FINAL: Clean up excessive whitespace and empty imports ==========
  cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
  cleaned = cleaned.replace(/import\s*{\s*}\s*from\s*['"][^'"]*['"]\s*;?\n?/g, '');
  
  // Remove trailing commas in plugin arrays
  cleaned = cleaned.replace(/,\s*,/g, ',');
  cleaned = cleaned.replace(/\[\s*,/g, '[');
  cleaned = cleaned.replace(/,\s*\]/g, ']');

  const wasModified = cleaned !== originalContent;

  return { cleaned, changes: [...new Set(changes)], wasModified, suspiciousPatterns };
}

/**
 * Clean package.json from proprietary packages - EXHAUSTIVE
 */
export function cleanPackageJson(content: string): { cleaned: string; changes: string[] } {
  const changes: string[] = [];
  
  try {
    const pkg = JSON.parse(content);
    
    // Remove suspicious packages
    for (const dep of SUSPICIOUS_PACKAGES) {
      if (pkg.dependencies?.[dep]) {
        delete pkg.dependencies[dep];
        changes.push(`Dépendance supprimée: ${dep}`);
      }
      if (pkg.devDependencies?.[dep]) {
        delete pkg.devDependencies[dep];
        changes.push(`DevDépendance supprimée: ${dep}`);
      }
    }
    
    // Clean scripts that reference proprietary tools
    if (pkg.scripts) {
      const scriptsToRemove = ['lovable', 'gpteng', 'bolt', 'v0', 'cursor', 'replit'];
      const keysToDelete: string[] = [];
      for (const [key, value] of Object.entries(pkg.scripts)) {
        if (typeof value === 'string') {
          for (const term of scriptsToRemove) {
            if (value.toLowerCase().includes(term)) {
              keysToDelete.push(key);
              changes.push(`Script supprimé: ${key}`);
              break;
            }
          }
        }
      }
      keysToDelete.forEach(key => delete pkg.scripts[key]);
    }
    
    // Remove repository fields pointing to proprietary platforms
    const proprietaryDomains = ['lovable', 'gptengineer', 'bolt.new', 'v0.dev', 'cursor', 'replit'];
    if (pkg.repository?.url) {
      for (const domain of proprietaryDomains) {
        if (pkg.repository.url.includes(domain)) {
          delete pkg.repository;
          changes.push('Repository propriétaire supprimé');
          break;
        }
      }
    }
    
    // Remove homepage if it points to proprietary platforms
    if (pkg.homepage) {
      for (const domain of proprietaryDomains) {
        if (pkg.homepage.includes(domain)) {
          delete pkg.homepage;
          changes.push('Homepage propriétaire supprimée');
          break;
        }
      }
    }
    
    // Remove bugs URL if proprietary
    if (pkg.bugs?.url) {
      for (const domain of proprietaryDomains) {
        if (pkg.bugs.url.includes(domain)) {
          delete pkg.bugs;
          changes.push('Bugs URL propriétaire supprimée');
          break;
        }
      }
    }
    
    // Remove author if it contains proprietary references
    if (typeof pkg.author === 'string') {
      for (const domain of proprietaryDomains) {
        if (pkg.author.toLowerCase().includes(domain)) {
          delete pkg.author;
          changes.push('Author propriétaire supprimé');
          break;
        }
      }
    }
    
    return { cleaned: JSON.stringify(pkg, null, 2), changes };
  } catch (e) {
    console.error('Error cleaning package.json:', e);
    return { cleaned: content, changes };
  }
}

/**
 * Clean vite.config.ts from proprietary plugins - EXHAUSTIVE
 * Now also handles dynamic imports and loadComponentTagger patterns
 */
export function cleanViteConfig(content: string): { cleaned: string; changes: string[] } {
  const changes: string[] = [];
  let cleaned = content;
  
  const before = cleaned;
  
  // Remove all proprietary imports (static)
  const importPatterns = [
    /import\s*{\s*componentTagger\s*}\s*from\s*['"]lovable-tagger['"]\s*;?\n?/g,
    /import\s*.*\s*from\s*['"]@lovable\/[^'"]*['"]\s*;?\n?/g,
    /import\s*.*\s*from\s*['"]@gptengineer\/[^'"]*['"]\s*;?\n?/g,
    /import\s*.*\s*from\s*['"]lovable-[^'"]*['"]\s*;?\n?/g,
    /import\s*.*\s*from\s*['"]@v0\/[^'"]*['"]\s*;?\n?/g,
    /import\s*.*\s*from\s*['"]@bolt\/[^'"]*['"]\s*;?\n?/g,
  ];
  
  for (const pattern of importPatterns) {
    cleaned = cleaned.replace(pattern, '');
  }
  
  // === NEW: Remove dynamic imports like import("lovable-tagger") or await import("lovable-tagger") ===
  const dynamicImportPatterns = [
    // await import("lovable-tagger")
    /await\s+import\s*\(\s*['"]lovable-tagger['"]\s*\)/g,
    // import("lovable-tagger")
    /import\s*\(\s*['"]lovable-tagger['"]\s*\)/g,
    // require("lovable-tagger")
    /require\s*\(\s*['"]lovable-tagger['"]\s*\)/g,
    // Any dynamic import of @lovable/*
    /await\s+import\s*\(\s*['"]@lovable\/[^'"]*['"]\s*\)/g,
    /import\s*\(\s*['"]@lovable\/[^'"]*['"]\s*\)/g,
    /require\s*\(\s*['"]@lovable\/[^'"]*['"]\s*\)/g,
  ];
  
  for (const pattern of dynamicImportPatterns) {
    const beforeDyn = cleaned;
    cleaned = cleaned.replace(pattern, 'null');
    if (cleaned !== beforeDyn) {
      changes.push('Import dynamique lovable-tagger supprimé');
    }
  }
  
  // === NEW: Remove entire loadComponentTagger function if present ===
  // Pattern: const loadComponentTagger = async () => { ... };
  const loadTaggerPattern = /const\s+loadComponentTagger\s*=\s*async\s*\(\s*\)\s*(?::\s*Promise<[^>]*>\s*)?\s*=>\s*\{[\s\S]*?\n\s*\};\n?/g;
  cleaned = cleaned.replace(loadTaggerPattern, '');
  
  // Also remove: const tagger = await loadComponentTagger();
  cleaned = cleaned.replace(/const\s+tagger\s*=\s*await\s+loadComponentTagger\s*\(\s*\)\s*;?\n?/g, '');
  
  // Remove tagger() calls in plugins array
  cleaned = cleaned.replace(/tagger\s*\(\s*\)\s*,?\n?/g, '');
  cleaned = cleaned.replace(/tagger\s*&&\s*tagger\s*\(\s*\)\s*,?\n?/g, '');
  
  // Remove plugin usages
  const pluginPatterns = [
    /mode\s*===\s*['"]development['"]\s*&&\s*componentTagger\(\)\s*,?\n?/g,
    /componentTagger\(\)\s*,?\n?/g,
    /lovableTagger\(\)\s*,?\n?/g,
    /gptEngineer\(\)\s*,?\n?/g,
  ];
  
  for (const pattern of pluginPatterns) {
    cleaned = cleaned.replace(pattern, '');
  }
  
  // Clean empty plugin arrays and trailing commas
  cleaned = cleaned.replace(/plugins:\s*\[\s*,?\s*\]/g, 'plugins: []');
  cleaned = cleaned.replace(/,\s*,/g, ',');
  cleaned = cleaned.replace(/\[\s*,/g, '[');
  cleaned = cleaned.replace(/,\s*\]/g, ']');
  cleaned = cleaned.replace(/,\s*\)/g, ')');
  
  // Clean up multiple newlines
  cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
  
  if (cleaned !== before) {
    changes.push('vite.config.ts nettoyé des plugins propriétaires');
  }
  
  return { cleaned, changes };
}

/**
 * Clean index.html from proprietary scripts and data attributes - EXHAUSTIVE
 */
export function cleanIndexHtml(content: string): { cleaned: string; changes: string[] } {
  const changes: string[] = [];
  let cleaned = content;
  
  const before = cleaned;
  
  // Remove script tags with proprietary references
  const scriptPatterns = [
    /<script[^>]*lovable[^>]*>[\s\S]*?<\/script>/gi,
    /<script[^>]*gptengineer[^>]*>[\s\S]*?<\/script>/gi,
    /<script[^>]*bolt[^>]*>[\s\S]*?<\/script>/gi,
    /<script[^>]*v0[^>]*>[\s\S]*?<\/script>/gi,
    /<script[^>]*cursor[^>]*>[\s\S]*?<\/script>/gi,
    /<script[^>]*replit[^>]*>[\s\S]*?<\/script>/gi,
  ];
  
  for (const pattern of scriptPatterns) {
    cleaned = cleaned.replace(pattern, '');
  }
  
  // Remove data attributes
  const dataAttrPatterns = [
    /\s*data-lov[^=]*="[^"]*"/g,
    /\s*data-gpt[^=]*="[^"]*"/g,
    /\s*data-bolt[^=]*="[^"]*"/g,
    /\s*data-v0[^=]*="[^"]*"/g,
    /\s*data-lovable[^=]*="[^"]*"/g,
  ];
  
  for (const pattern of dataAttrPatterns) {
    cleaned = cleaned.replace(pattern, '');
  }
  
  // Remove meta tags with proprietary references
  const metaPatterns = [
    /<meta[^>]*lovable[^>]*\/?>/gi,
    /<meta[^>]*gptengineer[^>]*\/?>/gi,
    /<meta[^>]*generator[^>]*lovable[^>]*\/?>/gi,
    /<meta[^>]*generator[^>]*gpt[^>]*\/?>/gi,
  ];
  
  for (const pattern of metaPatterns) {
    cleaned = cleaned.replace(pattern, '');
  }
  
  // Remove link tags to proprietary resources
  const linkPatterns = [
    /<link[^>]*lovable[^>]*\/?>/gi,
    /<link[^>]*gptengineer[^>]*\/?>/gi,
    /<link[^>]*bolt\.new[^>]*\/?>/gi,
  ];
  
  for (const pattern of linkPatterns) {
    cleaned = cleaned.replace(pattern, '');
  }
  
  // Remove comments with proprietary references
  cleaned = cleaned.replace(/<!--[\s\S]*?lovable[\s\S]*?-->/gi, '');
  cleaned = cleaned.replace(/<!--[\s\S]*?gptengineer[\s\S]*?-->/gi, '');
  
  if (cleaned !== before) {
    changes.push('index.html nettoyé des scripts et attributs propriétaires');
  }
  
  return { cleaned, changes };
}

/**
 * Clean CSS/SCSS files from proprietary references
 */
export function cleanStylesheet(content: string): { cleaned: string; changes: string[] } {
  const changes: string[] = [];
  let cleaned = content;
  const before = cleaned;
  
  // Remove CDN references
  for (const cdn of PROPRIETARY_ASSET_CDNS) {
    const cdnPattern = new RegExp(`url\\s*\\([^)]*${cdn.replace(/\./g, '\\.')}[^)]*\\)`, 'gi');
    if (cdnPattern.test(cleaned)) {
      cleaned = cleaned.replace(cdnPattern, 'url("")');
      changes.push(`CDN propriétaire supprimé: ${cdn}`);
    }
  }
  
  // Remove comments with proprietary references
  cleaned = cleaned.replace(/\/\*[\s\S]*?lovable[\s\S]*?\*\//gi, '');
  cleaned = cleaned.replace(/\/\*[\s\S]*?gptengineer[\s\S]*?\*\//gi, '');
  
  if (cleaned !== before) {
    changes.push('Stylesheet nettoyé');
  }
  
  return { cleaned, changes };
}

/**
 * Clean tsconfig.json from proprietary paths
 */
export function cleanTsConfig(content: string): { cleaned: string; changes: string[] } {
  const changes: string[] = [];
  
  try {
    const config = JSON.parse(content);
    
    // Remove paths pointing to integrations
    if (config.compilerOptions?.paths) {
      const pathsToRemove = Object.keys(config.compilerOptions.paths).filter(
        key => key.includes('integrations') || key.includes('lovable') || key.includes('gptengineer')
      );
      
      for (const path of pathsToRemove) {
        delete config.compilerOptions.paths[path];
        changes.push(`Path supprimé: ${path}`);
      }
    }
    
    // Remove include patterns for integrations
    if (Array.isArray(config.include)) {
      config.include = config.include.filter(
        (inc: string) => !inc.includes('integrations') && !inc.includes('lovable')
      );
    }
    
    return { cleaned: JSON.stringify(config, null, 2), changes };
  } catch (e) {
    return { cleaned: content, changes };
  }
}

/**
 * Clean .env files - remove hardcoded Supabase IDs and URLs
 */
export function cleanEnvFile(content: string): { cleaned: string; changes: string[]; wasModified: boolean; suspiciousPatterns: string[] } {
  let cleaned = content;
  const changes: string[] = [];
  const before = cleaned;
  
  // Replace hardcoded Supabase project IDs
  cleaned = cleaned.replace(/izqveyvcebolrqpqlmho/gi, 'your-project-id');
  cleaned = cleaned.replace(/[a-z]{20,30}\.supabase\.co/gi, 'your-project-id.supabase.co');
  
  // Replace Lovable URLs
  cleaned = cleaned.replace(/https?:\/\/[^\s]*lovable\.(app|dev)[^\s]*/gi, 'https://your-domain.com');
  cleaned = cleaned.replace(/https?:\/\/[^\s]*gptengineer\.(app|run)[^\s]*/gi, 'https://your-domain.com');
  
  // Replace JWT tokens (keeping structure but replacing value)
  cleaned = cleaned.replace(/eyJ[A-Za-z0-9_-]{100,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g, 'your-jwt-token');
  
  if (cleaned !== before) {
    changes.push('Variables .env nettoyées des IDs hardcodés');
  }
  
  return { cleaned, changes, wasModified: changes.length > 0, suspiciousPatterns: [] };
}

/**
 * Clean Markdown files - remove telemetry URLs and badges
 */
export function cleanMarkdownFile(content: string): { cleaned: string; changes: string[]; wasModified: boolean; suspiciousPatterns: string[] } {
  let cleaned = content;
  const changes: string[] = [];
  const before = cleaned;
  
  // Replace Lovable/GPTEngineer URLs
  cleaned = cleaned.replace(/https?:\/\/[^\s)\]]*lovable\.(app|dev)[^\s)\]]*/gi, 'https://your-app-url.com');
  cleaned = cleaned.replace(/https?:\/\/[^\s)\]]*gptengineer\.(app|run)[^\s)\]]*/gi, 'https://your-app-url.com');
  
  // Replace hardcoded Supabase project IDs
  cleaned = cleaned.replace(/izqveyvcebolrqpqlmho/gi, 'your-project-id');
  cleaned = cleaned.replace(/[a-z]{20,30}\.supabase\.co/gi, 'your-project-id.supabase.co');
  
  // Remove "Made with Lovable" badges
  cleaned = cleaned.replace(/\[!\[.*?lovable.*?\]\(.*?\)\]\(.*?\)/gi, '');
  cleaned = cleaned.replace(/\[!\[.*?gptengineer.*?\]\(.*?\)\]\(.*?\)/gi, '');
  
  // Remove "Built with" lines
  cleaned = cleaned.replace(/^.*built with.*lovable.*$/gim, '');
  cleaned = cleaned.replace(/^.*made with.*lovable.*$/gim, '');
  cleaned = cleaned.replace(/^.*powered by.*lovable.*$/gim, '');
  
  // Remove data-lov attributes mentioned in markdown
  cleaned = cleaned.replace(/data-lov[a-z-]*="[^"]*"/gi, '');
  
  // Replace JWT tokens
  cleaned = cleaned.replace(/eyJ[A-Za-z0-9_-]{100,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g, 'your-jwt-token');
  
  // Clean up empty lines
  cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
  
  if (cleaned !== before) {
    changes.push('README nettoyé des références propriétaires');
  }
  
  return { cleaned, changes, wasModified: changes.length > 0, suspiciousPatterns: [] };
}

/**
 * Clean shell script files - remove hardcoded IDs and URLs
 */
export function cleanShellScript(content: string): { cleaned: string; changes: string[]; wasModified: boolean; suspiciousPatterns: string[] } {
  let cleaned = content;
  const changes: string[] = [];
  const before = cleaned;
  
  // Replace hardcoded Supabase project IDs
  cleaned = cleaned.replace(/izqveyvcebolrqpqlmho/gi, '${SUPABASE_PROJECT_ID}');
  cleaned = cleaned.replace(/[a-z]{20,30}\.supabase\.co/gi, '${SUPABASE_PROJECT_ID}.supabase.co');
  
  // Replace Lovable URLs
  cleaned = cleaned.replace(/https?:\/\/[^\s"']*lovable\.(app|dev)[^\s"']*/gi, '${APP_URL}');
  
  // Replace JWT tokens
  cleaned = cleaned.replace(/eyJ[A-Za-z0-9_-]{100,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g, '${JWT_TOKEN}');
  
  if (cleaned !== before) {
    changes.push('Script shell nettoyé des IDs hardcodés');
  }
  
  return { cleaned, changes, wasModified: changes.length > 0, suspiciousPatterns: [] };
}

/**
 * Clean source file from proprietary patterns (basic client-side cleaning)
 * @deprecated Use deepCleanSourceFile for comprehensive cleaning
 */
export function cleanSourceFile(content: string): { cleaned: string; changes: string[] } {
  const changes: string[] = [];
  let cleaned = content;
  
  // Remove proprietary content patterns
  for (const pattern of PROPRIETARY_CONTENT) {
    const regex = new RegExp(pattern.source, pattern.flags);
    if (regex.test(cleaned)) {
      cleaned = cleaned.replace(new RegExp(pattern.source, pattern.flags), '');
      changes.push(`Pattern supprimé: ${pattern.source.substring(0, 30)}...`);
    }
  }
  
  // Remove telemetry domain references
  for (const domain of TELEMETRY_DOMAINS) {
    const domainPattern = new RegExp(`['"\`][^'"\`]*${domain.replace(/\./g, '\\.')}[^'"\`]*['"\`]`, 'gi');
    if (domainPattern.test(cleaned)) {
      cleaned = cleaned.replace(domainPattern, '""');
      changes.push(`Télémétrie supprimée: ${domain}`);
    }
  }
  
  // Clean up empty lines left behind
  cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
  
  return { cleaned, changes };
}

/**
 * Check for proprietary CDN assets (detection only, use cleanExternalAssetUrls for replacement)
 */
export function checkProprietaryCDN(content: string): { found: boolean; urls: string[] } {
  const urls: string[] = [];
  
  // Check all CDN domains
  for (const cdn of PROPRIETARY_ASSET_CDNS) {
    const escapedCdn = cdn.replace(/\./g, '\\.');
    const regex = new RegExp(`https?://[^'"\\s)]*${escapedCdn}[^'"\\s)]*`, 'gi');
    const matches = content.match(regex);
    if (matches) {
      urls.push(...matches);
    }
  }
  
  // Also check domains from EXTERNAL_ASSET_REPLACEMENTS
  for (const domain of Object.keys(EXTERNAL_ASSET_REPLACEMENTS)) {
    const escapedDomain = domain.replace(/\./g, '\\.');
    const regex = new RegExp(`https?://[^'"\\s)]*${escapedDomain}[^'"\\s)]*`, 'gi');
    const matches = content.match(regex);
    if (matches) {
      urls.push(...matches);
    }
  }
  
  // Remove duplicates
  const uniqueUrls = [...new Set(urls)];
  
  return { found: uniqueUrls.length > 0, urls: uniqueUrls };
}

/**
 * Detect which polyfills are needed based on file content - EXHAUSTIVE
 */
export function detectNeededPolyfills(files: Map<string, string>): string[] {
  const needed = new Set<string>();
  
  for (const [path, content] of files) {
    if (!path.match(/\.(ts|tsx|js|jsx)$/)) continue;
    
    // Check for use-mobile
    if (/useIsMobile|use-mobile|useMobile/i.test(content)) {
      if (/@lovable|@gptengineer|lovable-|gptengineer-|@\/hooks\/use-mobile|@\/components\/ui\/.*mobile/i.test(content)) {
        needed.add('use-mobile');
      }
    }
    
    // Check for use-toast 
    if (/useToast|use-toast/i.test(content)) {
      if (/@lovable|@gptengineer|lovable-|gptengineer-|@\/hooks\/use-toast|@\/components\/ui\/use-toast/i.test(content)) {
        needed.add('use-toast');
      }
    }
    
    // Check for use-sidebar
    if (/useSidebar|use-sidebar/i.test(content)) {
      if (/@lovable|@gptengineer|lovable-|gptengineer-|@\/hooks\/use-sidebar|@\/components\/ui\/sidebar/i.test(content)) {
        needed.add('use-sidebar');
      }
    }
    
    // Check for Supabase client usage
    if (/@\/integrations\/supabase\/client/i.test(content)) {
      needed.add('supabase-client');
    }
    
    // Check for useAuth
    if (/useAuth/i.test(content)) {
      if (/@\/hooks\/useAuth|@\/integrations\/supabase/i.test(content)) {
        needed.add('use-auth');
        needed.add('supabase-client');
      }
    }
  }
  
  return Array.from(needed);
}

/**
 * Generate .env.example from detected environment variables
 */
export function generateEnvExample(files: Map<string, string>): string {
  const envVars = new Set<string>();
  
  for (const [, content] of files) {
    // Match VITE_ and REACT_APP_ environment variables
    const matches = content.matchAll(/(?:import\.meta\.env\.|process\.env\.)(VITE_[A-Z_]+|REACT_APP_[A-Z_]+)/g);
    for (const match of matches) {
      // Skip proprietary env vars
      if (!match[1].includes('LOVABLE') && !match[1].includes('GPT') && !match[1].includes('PROJECT_ID')) {
        envVars.add(match[1]);
      }
    }
  }
  
  // Always include essential Supabase vars
  envVars.add('VITE_SUPABASE_URL');
  envVars.add('VITE_SUPABASE_ANON_KEY');
  
  let result = `# Variables d'environnement - Généré par Inopay Liberation
# Configurez ces valeurs avec votre propre infrastructure

# === SUPABASE (ou votre base de données) ===
VITE_SUPABASE_URL=https://your-project.supabase.co
VITE_SUPABASE_ANON_KEY=your-anon-key

`;
  
  for (const v of envVars) {
    if (!v.includes('SUPABASE')) {
      result += `${v}=\n`;
    }
  }
  
  return result;
}

/**
 * Calculate sovereignty score (0-100) - WEIGHTED SYSTEM
 * FIXED: Now uses contextual detection to avoid false positives
 */
export function calculateSovereigntyScore(
  originalFiles: Map<string, string>,
  cleanedFiles: Record<string, string>
): { score: number; details: string[] } {
  const details: string[] = [];
  let score = 100;
  
  // Helper: check if a match is in a REAL import statement (not a URL or string)
  const isRealImport = (content: string, keyword: string): boolean => {
    // Pattern for real ES6 imports: import ... from "keyword" or import("keyword")
    const importPatterns = [
      new RegExp(`import\\s+[^;]*from\\s*['"].*${escapeRegex(keyword)}.*['"]`, 'i'),
      new RegExp(`import\\s*\\(\\s*['"].*${escapeRegex(keyword)}.*['"]\\s*\\)`, 'i'),
      new RegExp(`require\\s*\\(\\s*['"].*${escapeRegex(keyword)}.*['"]\\s*\\)`, 'i'),
    ];
    return importPatterns.some(p => p.test(content));
  };
  
  // Helper: check if it's a real JS comment (not a URL like https://)
  const isRealComment = (content: string, keyword: string): boolean => {
    // Match // followed by keyword, but NOT after : (which would be in a URL)
    // Also match /* ... keyword ... */ block comments
    // Also match <!-- ... keyword ... --> HTML comments
    const lines = content.split('\n');
    for (const line of lines) {
      const trimmed = line.trim();
      // Skip if the line contains https:// or http:// before the keyword
      if (/https?:\/\/.*lovable/i.test(line)) continue;
      if (/https?:\/\/.*gptengineer/i.test(line)) continue;
      
      // Skip if it's a regex pattern definition (detection code, not proprietary comment)
      if (/\/.*lovable.*\//i.test(line) && !/^\/\//.test(trimmed)) continue;
      if (/\/.*gptengineer.*\//i.test(line) && !/^\/\//.test(trimmed)) continue;
      
      // Skip if it's a string in an array/object (detection patterns)
      if (/['"][^'"]*lovable[^'"]*['"]\s*[,:\]]/i.test(line)) continue;
      if (/['"][^'"]*gptengineer[^'"]*['"]\s*[,:\]]/i.test(line)) continue;
      
      // Check for real line comment: starts with // or has // not preceded by :
      // Exclude URLs by checking that // is not preceded by http: or https:
      const commentMatch = trimmed.match(/(?<!https?:)\/\/\s*.*$/i);
      if (commentMatch && commentMatch[0].toLowerCase().includes(keyword.toLowerCase())) {
        return true;
      }
    }
    // Check block comments (but not in regex patterns)
    const blockCommentPattern = new RegExp(`\\/\\*[\\s\\S]*?${escapeRegex(keyword)}[\\s\\S]*?\\*\\/`, 'i');
    if (blockCommentPattern.test(content)) {
      // Verify it's not inside a regex literal
      const match = content.match(blockCommentPattern);
      if (match && !/new RegExp|\.replace\(|\.test\(|\.match\(/.test(content.slice(Math.max(0, content.indexOf(match[0]) - 50), content.indexOf(match[0])))) {
        return true;
      }
    }
    // Check HTML comments
    if (new RegExp(`<!--[\\s\\S]*?${escapeRegex(keyword)}[\\s\\S]*?-->`, 'i').test(content)) {
      return true;
    }
    return false;
  };
  
  // Helper: escape regex special chars
  function escapeRegex(str: string): string {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
  
  // Helper: check if file is whitelisted (Inopay internal files)
  const isWhitelistedPath = (filePath: string): boolean => {
    const internalPaths = [
      'clientProprietaryPatterns',
      'proprietary-patterns',
      'security-cleaner',
      'BuildValidator',
      'sovereigntyReport',
      'SovereigntyAuditReport',
      'zipAnalyzer',
      'LiberationPackHub',
      '__tests__/aiReplacements',
      // Inopay project files that legitimately contain Supabase IDs or references
      'SovereignConnections',
      'sovereign-adapter',
      'STABILITY_REPORT',
      'deploy-inopay',
      'scripts/README',
      'MIGRATION_GUIDE',
      'docker-compose',
      'Dockerfile',
      'nginx.conf',
      '.env.example',
      'INSTALL.md',
      'self-host',
    ];
    return internalPaths.some(p => filePath.includes(p));
  };
  
  // Check for remaining proprietary patterns in cleaned files
  for (const [path, content] of Object.entries(cleanedFiles)) {
    // Skip lock files and node_modules
    if (path.includes('node_modules') || path.includes('package-lock') || path.includes('bun.lockb')) continue;
    
    // Skip Inopay internal files (they legitimately contain detection patterns)
    if (isWhitelistedPath(path)) continue;
    
    // CRITICAL: -20 points each
    // Check for remaining @/integrations imports (NOT standard @supabase/supabase-js)
    if (isRealImport(content, '@/integrations/supabase')) {
      score -= 20;
      details.push(`CRITIQUE: Import @/integrations restant dans ${path}`);
    }
    
    // Check for hardcoded Supabase project IDs (but not in this file itself if it's patterns file)
    if (!path.includes('clientProprietaryPatterns') && !path.includes('proprietary-patterns')) {
      for (const pattern of SUPABASE_PROJECT_PATTERNS) {
        if (new RegExp(pattern.source, pattern.flags).test(content)) {
          score -= 20;
          details.push(`CRITIQUE: ID Supabase hardcodé dans ${path}`);
          break;
        }
      }
    }
    
    // Check for exposed API keys
    for (const pattern of EXPOSED_KEYS_PATTERNS) {
      if (new RegExp(pattern.source, pattern.flags).test(content)) {
        score -= 20;
        details.push(`CRITIQUE: Clé API exposée dans ${path}`);
        break;
      }
    }
    
    // MAJOR: -10 points each
    // Check for remaining proprietary imports using CONTEXTUAL detection
    const proprietaryKeywords = [
      'lovable-tagger',
      '@lovable/',
      '@gptengineer/',
      '@bolt/',
      '@v0/',
      '@cursor/',
      '@/hooks/use-toast',
      '@/hooks/use-mobile',
    ];
    
    for (const keyword of proprietaryKeywords) {
      // Only penalize if it's a REAL import, not just text
      if (isRealImport(content, keyword)) {
        // Skip if we've already replaced with standard alternatives
        if (keyword === '@/hooks/use-toast' && content.includes("from 'sonner'")) continue;
        if (keyword === '@/hooks/use-mobile' && content.includes('const useIsMobile')) continue;
        if (keyword === 'lovable-tagger') {
          // Check it's not replaced with null
          if (/import\s*\(\s*['"]lovable-tagger['"]\s*\)/.test(content) === false) continue;
        }
        
        score -= 10;
        details.push(`MAJEUR: Import propriétaire '${keyword}' dans ${path}`);
        break;
      }
    }
    
    // Check for telemetry domains IN ACTUAL URLs (not just any text)
    for (const domain of TELEMETRY_DOMAINS) {
      // Only flag if domain appears in a URL-like context
      const urlPattern = new RegExp(`(https?:)?//[^\\s'"]*${escapeRegex(domain)}`, 'i');
      if (urlPattern.test(content)) {
        // Skip if this is the patterns file itself
        if (path.includes('clientProprietaryPatterns') || path.includes('proprietary-patterns')) continue;
        score -= 10;
        details.push(`MAJEUR: URL télémétrie ${domain} dans ${path}`);
        break;
      }
    }
    
    // Check for proprietary CDN
    const cdnCheck = checkProprietaryCDN(content);
    if (cdnCheck.found) {
      // Skip patterns file
      if (!path.includes('clientProprietaryPatterns') && !path.includes('proprietary-patterns')) {
        score -= 10;
        details.push(`MAJEUR: CDN propriétaire dans ${path}`);
      }
    }
    
    // MINOR: -5 points each
    // Check for data attributes (these are always bad)
    if (/data-lov-id|data-lov-component|data-gpt-|data-bolt-|data-v0-/.test(content)) {
      score -= 5;
      details.push(`MINEUR: Data attribute propriétaire dans ${path}`);
    }
    
    // Check for proprietary comments - using contextual detection
    if (isRealComment(content, 'lovable') || isRealComment(content, 'gptengineer')) {
      // Skip patterns file
      if (!path.includes('clientProprietaryPatterns') && !path.includes('proprietary-patterns')) {
        score -= 5;
        details.push(`MINEUR: Commentaire propriétaire dans ${path}`);
      }
    }
  }
  
  // BONUS: +5 points for good practices
  // Check if polyfills were generated
  if (Object.keys(cleanedFiles).some(p => p.includes('inopay-compat'))) {
    score = Math.min(100, score + 5);
  }
  
  // Check if .env.example exists
  if (Object.keys(cleanedFiles).some(p => p.includes('.env.example'))) {
    score = Math.min(100, score + 5);
  }
  
  return { 
    score: Math.max(0, Math.min(100, score)), 
    details: details.slice(0, 15) // Limit to 15 issues
  };
}

/**
 * Final verification pass - ensures 100% sovereignty
 * FIXED: Now skips patterns files and uses contextual detection
 */
export function finalVerificationPass(
  cleanedFiles: Record<string, string>
): { isClean: boolean; remainingIssues: string[]; criticalCount: number } {
  const remainingIssues: string[] = [];
  let criticalCount = 0;
  
  for (const [path, content] of Object.entries(cleanedFiles)) {
    // Skip non-source files
    if (!path.match(/\.(ts|tsx|js|jsx|json|html|css|scss)$/)) continue;
    
    // Skip patterns files (they legitimately contain these patterns for detection)
    if (path.includes('clientProprietaryPatterns') || path.includes('proprietary-patterns')) continue;
    if (path.includes('security-cleaner')) continue;
    
    // Check for any remaining proprietary references with CONTEXTUAL detection
    const criticalPatterns = [
      { 
        pattern: /import\s+[^;]*from\s*['"]@\/integrations\/supabase/g, 
        name: 'Import Supabase auto-généré' 
      },
      { 
        // Only match domains in URL context, not just any text
        pattern: /(?:https?:)?\/\/[^\s'"]*(?:lovable\.app|lovable\.dev|gptengineer\.app)/gi, 
        name: 'URL Lovable' 
      },
      { 
        pattern: /izqveyvcebolrqpqlmho/g, 
        name: 'ID projet Supabase' 
      },
      { 
        // JWT tokens (but not in patterns/test files)
        pattern: /['"]eyJ[A-Za-z0-9_-]{100,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+['"]/g, 
        name: 'Token JWT hardcodé' 
      },
    ];
    
    for (const { pattern, name } of criticalPatterns) {
      // Reset regex lastIndex
      pattern.lastIndex = 0;
      if (pattern.test(content)) {
        remainingIssues.push(`${path}: ${name}`);
        criticalCount++;
      }
    }
  }
  
  return {
    isClean: remainingIssues.length === 0,
    remainingIssues,
    criticalCount,
  };
}

// ============================================
// CENTRALIZED POLYFILLS V2 - Clean file-based approach
// These are generated as separate files, not injected inline
// ============================================

/**
 * Centralized polyfill file contents for Liberation Packs
 * Each polyfill is a complete, standalone file
 */
export const CENTRALIZED_POLYFILLS: Record<string, { path: string; content: string }> = {
  // Supabase client polyfill
  'supabase': {
    path: 'src/lib/supabase.ts',
    content: `/**
 * Supabase Client - Centralized Configuration
 * Generated by InoPay Liberation Pack
 * 
 * Configure your Supabase connection via environment variables:
 * - VITE_SUPABASE_URL: Your Supabase project URL
 * - VITE_SUPABASE_ANON_KEY: Your Supabase anon/public key
 */
import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/types/database';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  console.warn('Supabase credentials not configured. Set VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in your .env file.');
}

export const supabase = createClient<Database>(
  supabaseUrl || 'https://placeholder.supabase.co',
  supabaseAnonKey || 'placeholder-key',
  {
    auth: {
      storage: typeof window !== 'undefined' ? localStorage : undefined,
      persistSession: true,
      autoRefreshToken: true,
    }
  }
);

export default supabase;
`
  },

  // Database types polyfill
  'database': {
    path: 'src/types/database.ts',
    content: `/**
 * Database Types - Supabase Schema Types
 * Generated by InoPay Liberation Pack
 * 
 * To generate your own types from your Supabase project:
 * npx supabase gen types typescript --project-id="your-project-id" > src/types/database.ts
 */

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[];

/**
 * Generic Database interface
 * Replace this with your actual Supabase-generated types
 */
export interface Database {
  public: {
    Tables: {
      [key: string]: {
        Row: Record<string, unknown>;
        Insert: Record<string, unknown>;
        Update: Record<string, unknown>;
        Relationships: unknown[];
      };
    };
    Views: {
      [key: string]: {
        Row: Record<string, unknown>;
      };
    };
    Functions: {
      [key: string]: {
        Args: Record<string, unknown>;
        Returns: unknown;
      };
    };
    Enums: {
      [key: string]: string;
    };
    CompositeTypes: {
      [key: string]: unknown;
    };
  };
}

/**
 * Helper types for table operations
 */
export type Tables<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Row'];

export type TablesInsert<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Insert'];

export type TablesUpdate<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Update'];

/**
 * Enum helper type
 */
export type Enums<T extends keyof Database['public']['Enums']> = 
  Database['public']['Enums'][T];
`
  },

  // useIsMobile hook polyfill
  'use-mobile': {
    path: 'src/hooks/use-mobile.ts',
    content: `/**
 * useIsMobile Hook - Responsive breakpoint detection
 * Generated by InoPay Liberation Pack
 */
import { useState, useEffect } from 'react';

const MOBILE_BREAKPOINT = 768;

export function useIsMobile(): boolean {
  const [isMobile, setIsMobile] = useState<boolean>(() => {
    if (typeof window === 'undefined') return false;
    return window.innerWidth < MOBILE_BREAKPOINT;
  });

  useEffect(() => {
    if (typeof window === 'undefined') return;

    const mql = window.matchMedia(\`(max-width: \${MOBILE_BREAKPOINT - 1}px)\`);
    
    const onChange = (e: MediaQueryListEvent | MediaQueryList) => {
      setIsMobile(e.matches);
    };

    // Set initial value
    onChange(mql);

    // Listen for changes
    if (mql.addEventListener) {
      mql.addEventListener('change', onChange);
      return () => mql.removeEventListener('change', onChange);
    } else {
      // Fallback for older browsers
      mql.addListener(onChange);
      return () => mql.removeListener(onChange);
    }
  }, []);

  return isMobile;
}

export default useIsMobile;
`
  },

  // useToast hook polyfill (wrapper for sonner)
  'use-toast': {
    path: 'src/hooks/use-toast.ts',
    content: `/**
 * useToast Hook - Toast notification wrapper for sonner
 * Generated by InoPay Liberation Pack
 * 
 * This provides compatibility with useToast pattern while using sonner
 */
import { toast as sonnerToast } from 'sonner';

export interface ToastProps {
  title?: string;
  description?: string;
  variant?: 'default' | 'destructive';
  duration?: number;
}

export function toast(props: ToastProps | string) {
  if (typeof props === 'string') {
    sonnerToast(props);
    return;
  }

  const { title, description, variant, duration } = props;
  const message = title || description || '';
  const options = { description: title ? description : undefined, duration };

  if (variant === 'destructive') {
    sonnerToast.error(message, options);
  } else {
    sonnerToast(message, options);
  }
}

export function useToast() {
  return { toast };
}

// Re-export sonner toast for direct usage
export { toast as sonnerToast } from 'sonner';
`
  }
};

/**
 * Get list of required polyfills based on file contents
 * Returns the polyfill keys that need to be generated
 */
export function getRequiredPolyfills(files: Record<string, string> | Map<string, string>): string[] {
  const needed: Set<string> = new Set();
  
  const entries = files instanceof Map ? Array.from(files.entries()) : Object.entries(files);
  
  for (const [path, content] of entries) {
    // Skip non-source files
    if (!path.match(/\.(ts|tsx|js|jsx)$/)) continue;
    
    // Check for Supabase usage
    if (/from\s+['"]@\/lib\/supabase['"]/.test(content) ||
        /from\s+['"]@\/integrations\/supabase\/client['"]/.test(content) ||
        /supabase\.from\s*\(/.test(content) ||
        /supabase\.auth\./.test(content)) {
      needed.add('supabase');
      needed.add('database'); // Always include types with client
    }
    
    // Check for type imports
    if (/from\s+['"]@\/types\/database['"]/.test(content) ||
        /from\s+['"]@\/integrations\/supabase\/types['"]/.test(content) ||
        /\bDatabase\b/.test(content) ||
        /\bTables</.test(content) ||
        /\bTablesInsert</.test(content) ||
        /\bTablesUpdate</.test(content)) {
      needed.add('database');
    }
    
    // Check for useIsMobile
    if (/useIsMobile/.test(content) ||
        /from\s+['"]@\/hooks\/use-mobile['"]/.test(content)) {
      needed.add('use-mobile');
    }
    
    // Check for useToast (if not already converted to sonner)
    if (/from\s+['"]@\/hooks\/use-toast['"]/.test(content) ||
        /from\s+['"]@\/components\/ui\/use-toast['"]/.test(content) ||
        /useToast\s*\(\s*\)/.test(content)) {
      needed.add('use-toast');
    }
  }
  
  return Array.from(needed);
}

/**
 * Generate all required polyfill files for a Liberation Pack
 */
export function generatePolyfillFiles(requiredPolyfills: string[]): Record<string, string> {
  const files: Record<string, string> = {};
  
  for (const key of requiredPolyfills) {
    const polyfill = CENTRALIZED_POLYFILLS[key];
    if (polyfill) {
      files[polyfill.path] = polyfill.content;
    }
  }
  
  return files;
}

// ============================================
// NCS PHASE 1: PROJECT GRAPH GENERATOR
// ============================================

export interface ProjectGraph {
  name: string;
  framework: string;
  structure: {
    hasBackend: boolean;
    hasFrontend: boolean;
    hasDatabase: boolean;
    hasEdgeFunctions: boolean;
  };
  files: {
    total: number;
    frontend: number;
    backend: number;
    config: number;
    assets: number;
  };
  dependencies: {
    total: number;
    proprietary: string[];
    cloudServices: string[];
  };
  edgeFunctions: string[];
  envVars: string[];
  webhooks: string[];
  assets: string[];
}

export function generateProjectGraph(
  files: Record<string, string>,
  projectName: string = 'project'
): ProjectGraph {
  const allContent = Object.values(files).join('\n');
  const filePaths = Object.keys(files);
  
  // Detect framework
  let framework = 'unknown';
  if (allContent.includes('next/') || files['next.config.js']) framework = 'next.js';
  else if (allContent.includes('nuxt') || files['nuxt.config.ts']) framework = 'nuxt';
  else if (allContent.includes('svelte') || files['svelte.config.js']) framework = 'sveltekit';
  else if (files['vite.config.ts'] || files['vite.config.js']) framework = 'vite-react';
  else if (files['angular.json']) framework = 'angular';
  else if (files['package.json'] && allContent.includes('"react"')) framework = 'react';
  
  // Detect structure
  const hasBackend = filePaths.some(p => 
    p.includes('supabase/functions/') || 
    p.includes('api/') || 
    p.includes('server/') ||
    p.includes('backend/')
  );
  const hasFrontend = filePaths.some(p => 
    p.includes('src/') || 
    p.includes('pages/') || 
    p.includes('components/')
  );
  const hasDatabase = filePaths.some(p => 
    p.includes('migrations/') || 
    p.includes('schema.sql') ||
    p.includes('prisma/')
  );
  const hasEdgeFunctions = filePaths.some(p => p.includes('supabase/functions/'));
  
  // Count files by category
  const frontendFiles = filePaths.filter(p => 
    p.match(/\.(tsx|jsx|css|scss|html)$/) && !p.includes('supabase/')
  ).length;
  const backendFiles = filePaths.filter(p => 
    p.includes('supabase/functions/') || 
    p.includes('api/') ||
    (p.match(/\.(ts|js)$/) && (p.includes('server/') || p.includes('backend/')))
  ).length;
  const configFiles = filePaths.filter(p => 
    p.match(/\.(json|toml|yaml|yml|config\.[jt]s)$/)
  ).length;
  const assetFiles = filePaths.filter(p => 
    p.match(/\.(png|jpg|jpeg|gif|svg|webp|ico|pdf|mp4|mp3|woff|woff2)$/)
  ).length;
  
  // Detect proprietary dependencies
  const proprietaryDeps: string[] = [];
  for (const pkg of SUSPICIOUS_PACKAGES) {
    if (allContent.includes(`"${pkg}"`)) {
      proprietaryDeps.push(pkg);
    }
  }
  
  // Detect cloud services
  const cloudServices = detectCloudServices(files);
  
  // Detect edge functions
  const edgeFunctions = filePaths
    .filter(p => p.match(/supabase\/functions\/[^\/]+\/index\.ts$/))
    .map(p => p.split('/')[2]);
  
  // Detect env vars
  const envVars = new Set<string>();
  const envMatches = allContent.matchAll(/(?:Deno\.env\.get|process\.env|import\.meta\.env)\s*[\.\[\(]\s*['"]?([A-Z_][A-Z0-9_]*)['"]?\s*[\]\)]?/g);
  for (const match of envMatches) {
    envVars.add(match[1]);
  }
  
  // Detect webhooks
  const webhooks: string[] = [];
  if (allContent.includes('stripe-signature')) webhooks.push('stripe');
  if (allContent.includes('x-hub-signature')) webhooks.push('github');
  if (allContent.includes('x-twilio-signature')) webhooks.push('twilio');
  
  // Detect assets
  const assets = filePaths.filter(p => 
    p.match(/\.(png|jpg|jpeg|gif|svg|webp|ico)$/) && 
    !p.includes('node_modules')
  );
  
  return {
    name: projectName,
    framework,
    structure: {
      hasBackend,
      hasFrontend,
      hasDatabase,
      hasEdgeFunctions,
    },
    files: {
      total: filePaths.length,
      frontend: frontendFiles,
      backend: backendFiles,
      config: configFiles,
      assets: assetFiles,
    },
    dependencies: {
      total: proprietaryDeps.length + cloudServices.length,
      proprietary: proprietaryDeps,
      cloudServices,
    },
    edgeFunctions,
    envVars: Array.from(envVars),
    webhooks,
    assets,
  };
}

// ============================================
// NCS PHASE 2: CLOUD SERVICES DETECTION
// ============================================

export const CLOUD_SERVICES_PATTERNS: { name: string; patterns: RegExp[]; replacement?: string }[] = [
  // Vercel
  { name: 'Vercel KV', patterns: [/@vercel\/kv/g, /VERCEL_KV/g], replacement: 'Redis self-hosted' },
  { name: 'Vercel Postgres', patterns: [/@vercel\/postgres/g], replacement: 'PostgreSQL self-hosted' },
  { name: 'Vercel Edge', patterns: [/@vercel\/edge/g, /vercel\/edge-runtime/g], replacement: 'Express.js' },
  { name: 'Vercel Blob', patterns: [/@vercel\/blob/g], replacement: 'MinIO' },
  { name: 'Vercel Analytics', patterns: [/@vercel\/analytics/g], replacement: 'Plausible' },
  
  // Firebase
  { name: 'Firebase Auth', patterns: [/firebase\/auth/g, /getAuth\s*\(/g], replacement: 'Supabase Auth' },
  { name: 'Firebase Firestore', patterns: [/firebase\/firestore/g, /getFirestore\s*\(/g], replacement: 'PostgreSQL' },
  { name: 'Firebase Storage', patterns: [/firebase\/storage/g, /getStorage\s*\(/g], replacement: 'MinIO' },
  { name: 'Firebase Functions', patterns: [/firebase-functions/g], replacement: 'Express.js' },
  
  // Cloudflare
  { name: 'Cloudflare Workers', patterns: [/cloudflare\/workers/g, /@cloudflare\/workers-types/g], replacement: 'Express.js' },
  { name: 'Cloudflare KV', patterns: [/env\.KV/g, /CLOUDFLARE_KV/g], replacement: 'Redis' },
  { name: 'Cloudflare R2', patterns: [/R2Bucket/g, /@cloudflare\/r2/g], replacement: 'MinIO' },
  { name: 'Cloudflare D1', patterns: [/D1Database/g, /@cloudflare\/d1/g], replacement: 'PostgreSQL' },
  
  // AWS
  { name: 'AWS Lambda', patterns: [/aws-lambda/g, /APIGatewayProxyEvent/g], replacement: 'Express.js' },
  { name: 'AWS S3', patterns: [/@aws-sdk\/client-s3/g, /S3Client/g], replacement: 'MinIO' },
  { name: 'AWS DynamoDB', patterns: [/@aws-sdk\/client-dynamodb/g, /DynamoDBClient/g], replacement: 'PostgreSQL' },
  { name: 'AWS Cognito', patterns: [/@aws-sdk\/client-cognito/g, /CognitoIdentityClient/g], replacement: 'Supabase Auth' },
  
  // Appwrite Cloud
  { name: 'Appwrite', patterns: [/appwrite/g], replacement: 'Supabase' },
  
  // Neon
  { name: 'Neon DB', patterns: [/@neondatabase\/serverless/g, /neon\.tech/g], replacement: 'PostgreSQL' },
  
  // PlanetScale
  { name: 'PlanetScale', patterns: [/@planetscale\/database/g, /planetscale\.com/g], replacement: 'PostgreSQL' },
  
  // Upstash
  { name: 'Upstash Redis', patterns: [/@upstash\/redis/g], replacement: 'Redis self-hosted' },
  { name: 'Upstash Kafka', patterns: [/@upstash\/kafka/g], replacement: 'Kafka self-hosted' },
  
  // Algolia
  { name: 'Algolia', patterns: [/algoliasearch/g, /algolia/g], replacement: 'Meilisearch' },
  
  // Stripe (partial - payments require careful migration)
  { name: 'Stripe', patterns: [/stripe/gi], replacement: 'Keep Stripe or use Paddle' },
];

export function detectCloudServices(files: Record<string, string>): string[] {
  const allContent = Object.values(files).join('\n');
  const detected: string[] = [];
  
  for (const service of CLOUD_SERVICES_PATTERNS) {
    for (const pattern of service.patterns) {
      const freshPattern = new RegExp(pattern.source, pattern.flags);
      if (freshPattern.test(allContent)) {
        if (!detected.includes(service.name)) {
          detected.push(service.name);
        }
        break;
      }
    }
  }
  
  return detected;
}

// ============================================
// NCS PHASE 2: PROPRIETARY MAP GENERATOR
// ============================================

export interface ProprietaryMapEntry {
  file: string;
  line: number;
  column: number;
  type: 'import' | 'content' | 'telemetry' | 'cloud-service' | 'api-key' | 'backdoor';
  pattern: string;
  action: 'remove' | 'replace' | 'rewrite';
  replacement?: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
}

export interface ProprietaryMap {
  totalIssues: number;
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
  entries: ProprietaryMapEntry[];
  summary: {
    importsToRemove: number;
    contentToClean: number;
    telemetryToBlock: number;
    cloudServicesToReplace: number;
    apiKeysExposed: number;
    backdoorsDetected: number;
  };
}

export function generateProprietaryMap(files: Record<string, string>): ProprietaryMap {
  const entries: ProprietaryMapEntry[] = [];
  
  for (const [filePath, content] of Object.entries(files)) {
    // Skip non-source files
    if (!filePath.match(/\.(ts|tsx|js|jsx|json|html|css)$/)) continue;
    if (filePath.includes('node_modules')) continue;
    
    const lines = content.split('\n');
    
    lines.forEach((line, index) => {
      const lineNum = index + 1;
      
      // Check proprietary imports
      for (const pattern of PROPRIETARY_IMPORTS) {
        const freshPattern = new RegExp(pattern.source, pattern.flags);
        if (freshPattern.test(line)) {
          entries.push({
            file: filePath,
            line: lineNum,
            column: 1,
            type: 'import',
            pattern: pattern.source,
            action: 'remove',
            severity: 'high',
          });
        }
      }
      
      // Check telemetry domains
      for (const domain of TELEMETRY_DOMAINS) {
        if (line.includes(domain)) {
          entries.push({
            file: filePath,
            line: lineNum,
            column: line.indexOf(domain) + 1,
            type: 'telemetry',
            pattern: domain,
            action: 'remove',
            severity: 'critical',
          });
        }
      }
      
      // Check cloud services
      for (const service of CLOUD_SERVICES_PATTERNS) {
        for (const pattern of service.patterns) {
          const freshPattern = new RegExp(pattern.source, pattern.flags);
          if (freshPattern.test(line)) {
            entries.push({
              file: filePath,
              line: lineNum,
              column: 1,
              type: 'cloud-service',
              pattern: service.name,
              action: 'replace',
              replacement: service.replacement,
              severity: 'medium',
            });
            break;
          }
        }
      }
      
      // Check exposed API keys
      for (const pattern of EXPOSED_KEYS_PATTERNS) {
        const freshPattern = new RegExp(pattern.source, pattern.flags);
        if (freshPattern.test(line)) {
          entries.push({
            file: filePath,
            line: lineNum,
            column: 1,
            type: 'api-key',
            pattern: pattern.source,
            action: 'replace',
            severity: 'critical',
          });
        }
      }
    });
  }
  
  // Count by severity
  const criticalCount = entries.filter(e => e.severity === 'critical').length;
  const highCount = entries.filter(e => e.severity === 'high').length;
  const mediumCount = entries.filter(e => e.severity === 'medium').length;
  const lowCount = entries.filter(e => e.severity === 'low').length;
  
  return {
    totalIssues: entries.length,
    criticalCount,
    highCount,
    mediumCount,
    lowCount,
    entries,
    summary: {
      importsToRemove: entries.filter(e => e.type === 'import').length,
      contentToClean: entries.filter(e => e.type === 'content').length,
      telemetryToBlock: entries.filter(e => e.type === 'telemetry').length,
      cloudServicesToReplace: entries.filter(e => e.type === 'cloud-service').length,
      apiKeysExposed: entries.filter(e => e.type === 'api-key').length,
      backdoorsDetected: entries.filter(e => e.type === 'backdoor').length,
    },
  };
}

// ============================================
// NCS PHASE 3: SECURITY AUDIT (ANTI-BACKDOORS)
// ============================================

export interface SecurityIssue {
  file: string;
  line: number;
  column: number;
  type: 'dangerous-function' | 'suspicious-dns' | 'credential-leak' | 'hidden-telemetry' | 'eval-usage' | 'dynamic-code';
  pattern: string;
  description: string;
  severity: 'info' | 'warning' | 'error' | 'critical';
  recommendation: string;
}

export interface SecurityReport {
  isSecure: boolean;
  score: number; // 0-100
  totalIssues: number;
  criticalIssues: number;
  errorIssues: number;
  warningIssues: number;
  infoIssues: number;
  issues: SecurityIssue[];
  summary: string;
}

export const SECURITY_PATTERNS = {
  dangerousFunctions: [
    { pattern: /\beval\s*\(/g, name: 'eval()', severity: 'critical' as const, description: 'Exécution de code dynamique - risque d\'injection' },
    { pattern: /new\s+Function\s*\(/g, name: 'new Function()', severity: 'critical' as const, description: 'Création de fonction dynamique - risque d\'injection' },
    { pattern: /\bexec\s*\(/g, name: 'exec()', severity: 'error' as const, description: 'Exécution de commande système' },
    { pattern: /\bspawn\s*\(/g, name: 'spawn()', severity: 'warning' as const, description: 'Processus fils - vérifier l\'usage' },
    { pattern: /child_process/g, name: 'child_process', severity: 'warning' as const, description: 'Module d\'exécution de processus' },
    { pattern: /\$\{.*\}\s*`/g, name: 'Template string eval', severity: 'warning' as const, description: 'Template string potentiellement dangereux' },
  ],
  suspiciousDNS: [
    { pattern: /fetch\s*\([^)]*(?!localhost|127\.0\.0\.1|your-project)[a-z0-9-]+\.[a-z]{2,}/gi, name: 'External fetch', severity: 'warning' as const },
    { pattern: /new\s+WebSocket\s*\([^)]*(?!localhost|127\.0\.0\.1)[a-z0-9-]+\.[a-z]{2,}/gi, name: 'External WebSocket', severity: 'warning' as const },
    { pattern: /XMLHttpRequest|\.open\s*\(\s*['"][A-Z]+['"]\s*,\s*['"]/g, name: 'XHR request', severity: 'info' as const },
  ],
  credentialLeaks: [
    { pattern: /api[_-]?key\s*[:=]\s*['"][A-Za-z0-9_-]{20,}['"]/gi, name: 'Hardcoded API key', severity: 'critical' as const },
    { pattern: /password\s*[:=]\s*['"][^'"]{8,}['"]/gi, name: 'Hardcoded password', severity: 'critical' as const },
    { pattern: /secret\s*[:=]\s*['"][A-Za-z0-9_-]{20,}['"]/gi, name: 'Hardcoded secret', severity: 'critical' as const },
    { pattern: /private[_-]?key\s*[:=]\s*['"][^'"]+['"]/gi, name: 'Private key in code', severity: 'critical' as const },
    { pattern: /sk_live_[A-Za-z0-9]+/g, name: 'Stripe live key', severity: 'critical' as const },
    { pattern: /eyJ[A-Za-z0-9_-]{100,}/g, name: 'JWT token', severity: 'error' as const },
  ],
  hiddenTelemetry: [
    { pattern: /navigator\.sendBeacon\s*\(/g, name: 'sendBeacon', severity: 'warning' as const },
    { pattern: /new\s+Image\s*\(\s*\)\s*\.src\s*=/g, name: 'Tracking pixel', severity: 'warning' as const },
    { pattern: /performance\.mark|performance\.measure/g, name: 'Performance API', severity: 'info' as const },
  ],
};

export function runSecurityAudit(files: Record<string, string>): SecurityReport {
  const issues: SecurityIssue[] = [];
  
  for (const [filePath, content] of Object.entries(files)) {
    // Skip non-source files
    if (!filePath.match(/\.(ts|tsx|js|jsx)$/)) continue;
    if (filePath.includes('node_modules')) continue;
    
    const lines = content.split('\n');
    
    lines.forEach((line, index) => {
      const lineNum = index + 1;
      
      // Check dangerous functions
      for (const { pattern, name, severity, description } of SECURITY_PATTERNS.dangerousFunctions) {
        const freshPattern = new RegExp(pattern.source, pattern.flags);
        if (freshPattern.test(line)) {
          issues.push({
            file: filePath,
            line: lineNum,
            column: 1,
            type: severity === 'critical' ? 'eval-usage' : 'dangerous-function',
            pattern: name,
            description,
            severity,
            recommendation: `Supprimez ou remplacez ${name} par une alternative sécurisée`,
          });
        }
      }
      
      // Check suspicious DNS
      for (const { pattern, name, severity } of SECURITY_PATTERNS.suspiciousDNS) {
        const freshPattern = new RegExp(pattern.source, pattern.flags);
        const match = freshPattern.exec(line);
        if (match) {
          // Exclude known safe domains
          const safeDomains = ['localhost', '127.0.0.1', 'supabase.co', 'your-project'];
          const isSafe = safeDomains.some(d => match[0].includes(d));
          if (!isSafe) {
            issues.push({
              file: filePath,
              line: lineNum,
              column: 1,
              type: 'suspicious-dns',
              pattern: name,
              description: `Appel réseau externe détecté: ${match[0].substring(0, 50)}...`,
              severity,
              recommendation: 'Vérifiez que cette URL est légitime et documentée',
            });
          }
        }
      }
      
      // Check credential leaks
      for (const { pattern, name, severity } of SECURITY_PATTERNS.credentialLeaks) {
        const freshPattern = new RegExp(pattern.source, pattern.flags);
        if (freshPattern.test(line)) {
          issues.push({
            file: filePath,
            line: lineNum,
            column: 1,
            type: 'credential-leak',
            pattern: name,
            description: `Credential potentiellement exposé: ${name}`,
            severity,
            recommendation: 'Déplacez vers des variables d\'environnement (.env)',
          });
        }
      }
      
      // Check hidden telemetry
      for (const { pattern, name, severity } of SECURITY_PATTERNS.hiddenTelemetry) {
        const freshPattern = new RegExp(pattern.source, pattern.flags);
        if (freshPattern.test(line)) {
          issues.push({
            file: filePath,
            line: lineNum,
            column: 1,
            type: 'hidden-telemetry',
            pattern: name,
            description: `Télémétrie potentielle détectée: ${name}`,
            severity,
            recommendation: 'Vérifiez que ce tracking est documenté et consenti',
          });
        }
      }
    });
  }
  
  // Calculate score
  let score = 100;
  for (const issue of issues) {
    switch (issue.severity) {
      case 'critical': score -= 25; break;
      case 'error': score -= 15; break;
      case 'warning': score -= 5; break;
      case 'info': score -= 1; break;
    }
  }
  score = Math.max(0, Math.min(100, score));
  
  const criticalIssues = issues.filter(i => i.severity === 'critical').length;
  const errorIssues = issues.filter(i => i.severity === 'error').length;
  const warningIssues = issues.filter(i => i.severity === 'warning').length;
  const infoIssues = issues.filter(i => i.severity === 'info').length;
  
  let summary = '';
  if (score >= 90) summary = '✅ Code sécurisé - aucun problème critique';
  else if (score >= 70) summary = '⚠️ Code partiellement sécurisé - quelques corrections nécessaires';
  else if (score >= 50) summary = '🔶 Attention - plusieurs problèmes de sécurité détectés';
  else summary = '🔴 Critique - nombreux problèmes de sécurité à corriger';
  
  return {
    isSecure: criticalIssues === 0,
    score,
    totalIssues: issues.length,
    criticalIssues,
    errorIssues,
    warningIssues,
    infoIssues,
    issues,
    summary,
  };
}

// ============================================
// NCS PHASE 5: SMOKE TESTS GENERATOR
// ============================================

export function generateSmokeTests(
  routes: string[],
  projectName: string
): string {
  return `/**
 * Smoke Tests - ${projectName}
 * Generated by InoPay Liberation Pack
 * 
 * Run: npm test or npx vitest
 */
import { describe, it, expect, beforeAll, afterAll } from 'vitest';

const API_URL = process.env.API_URL || 'http://localhost:3000';

describe('🧪 API Smoke Tests', () => {
  beforeAll(async () => {
    console.log('Starting smoke tests against:', API_URL);
  });

  afterAll(() => {
    console.log('Smoke tests completed');
  });

  it('should respond to health check', async () => {
    const response = await fetch(\`\${API_URL}/health\`);
    expect(response.status).toBe(200);
  });

  it('should have valid CORS headers', async () => {
    const response = await fetch(\`\${API_URL}/health\`, {
      method: 'OPTIONS',
    });
    expect(response.headers.get('access-control-allow-origin')).toBeTruthy();
  });

${routes.map(route => `
  it('${route} endpoint should respond', async () => {
    try {
      const response = await fetch(\`\${API_URL}/api/${route}\`, {
        method: 'OPTIONS',
      });
      // Accept 200, 204 (CORS), 401 (auth required), 405 (method not allowed)
      expect([200, 204, 401, 405]).toContain(response.status);
    } catch (error) {
      // Network error is acceptable if endpoint exists but has issues
      console.warn('${route} endpoint check failed:', error);
    }
  });
`).join('')}
});

describe('🎨 Frontend Smoke Tests', () => {
  const FRONTEND_URL = process.env.FRONTEND_URL || 'http://localhost:5173';

  it('should serve index.html', async () => {
    const response = await fetch(FRONTEND_URL);
    expect(response.status).toBe(200);
    expect(response.headers.get('content-type')).toContain('text/html');
  });

  it('should serve static assets', async () => {
    const response = await fetch(\`\${FRONTEND_URL}/favicon.ico\`);
    // 200 or 404 are both acceptable
    expect([200, 404]).toContain(response.status);
  });
});

describe('📊 Database Smoke Tests', () => {
  it.skip('should connect to database', async () => {
    // Uncomment and configure for your database
    // const client = new Pool({ connectionString: process.env.DATABASE_URL });
    // const result = await client.query('SELECT NOW()');
    // expect(result.rows).toHaveLength(1);
  });
});
`;
}

// ============================================
// NCS PHASE 6: COOLIFY READINESS CHECK
// ============================================

export interface CoolifyReadiness {
  ready: boolean;
  score: number; // 0-100
  checks: {
    dockerfile: { passed: boolean; issues: string[] };
    dependencies: { passed: boolean; missing: string[] };
    envVars: { passed: boolean; required: string[]; missing: string[] };
    ports: { passed: boolean; exposed: number[] };
    healthcheck: { passed: boolean; path?: string };
    noProprietaryRuntime: { passed: boolean; found: string[] };
  };
  recommendations: string[];
}

export function checkCoolifyReadiness(files: Record<string, string>): CoolifyReadiness {
  const issues: string[] = [];
  const recommendations: string[] = [];
  
  // Check Dockerfile
  const dockerfileContent = files['Dockerfile'] || files['frontend/Dockerfile'] || '';
  const hasDockerfile = !!dockerfileContent;
  const dockerfileIssues: string[] = [];
  
  if (!hasDockerfile) {
    dockerfileIssues.push('Aucun Dockerfile trouvé');
  } else {
    if (!dockerfileContent.includes('FROM')) {
      dockerfileIssues.push('Dockerfile invalide - pas de FROM');
    }
    if (!dockerfileContent.includes('EXPOSE')) {
      dockerfileIssues.push('Aucun port EXPOSE déclaré');
    }
    if (dockerfileContent.includes('VERCEL') || dockerfileContent.includes('vercel')) {
      dockerfileIssues.push('Référence à Vercel dans Dockerfile');
    }
  }
  
  // Check dependencies
  const packageJsonContent = files['package.json'] || files['frontend/package.json'] || '{}';
  let packageJson: any = {};
  try {
    packageJson = JSON.parse(packageJsonContent);
  } catch {}
  
  const allDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };
  const missingDeps: string[] = [];
  const requiredDeps = ['react', 'react-dom'];
  
  for (const dep of requiredDeps) {
    if (!allDeps[dep]) {
      missingDeps.push(dep);
    }
  }
  
  // Check env vars
  const allContent = Object.values(files).join('\n');
  const envVarsFound = new Set<string>();
  const envMatches = allContent.matchAll(/(?:import\.meta\.env|process\.env)\s*\.?\s*([A-Z_][A-Z0-9_]*)/g);
  for (const match of envMatches) {
    envVarsFound.add(match[1]);
  }
  
  const envExampleContent = files['.env.example'] || files['frontend/.env.example'] || '';
  const envVarsDefined = new Set<string>();
  const envDefMatches = envExampleContent.matchAll(/^([A-Z_][A-Z0-9_]*)=/gm);
  for (const match of envDefMatches) {
    envVarsDefined.add(match[1]);
  }
  
  const missingEnvVars = Array.from(envVarsFound).filter(v => !envVarsDefined.has(v));
  
  // Check ports
  const ports: number[] = [];
  const portMatches = dockerfileContent.matchAll(/EXPOSE\s+(\d+)/g);
  for (const match of portMatches) {
    ports.push(parseInt(match[1]));
  }
  
  // Check healthcheck
  const hasHealthcheck = dockerfileContent.includes('HEALTHCHECK') || 
    allContent.includes('/health') || 
    allContent.includes('healthcheck');
  
  // Check for proprietary runtimes
  const proprietaryRuntimes: string[] = [];
  if (allContent.includes('@vercel/edge')) proprietaryRuntimes.push('Vercel Edge Runtime');
  if (allContent.includes('netlify-edge')) proprietaryRuntimes.push('Netlify Edge');
  if (allContent.includes('@cloudflare/workers')) proprietaryRuntimes.push('Cloudflare Workers');
  
  // Calculate score
  let score = 100;
  if (!hasDockerfile) score -= 30;
  if (dockerfileIssues.length > 0) score -= dockerfileIssues.length * 5;
  if (missingDeps.length > 0) score -= missingDeps.length * 5;
  if (missingEnvVars.length > 0) score -= Math.min(missingEnvVars.length * 2, 20);
  if (ports.length === 0) score -= 10;
  if (!hasHealthcheck) score -= 10;
  if (proprietaryRuntimes.length > 0) score -= proprietaryRuntimes.length * 15;
  
  score = Math.max(0, Math.min(100, score));
  
  // Generate recommendations
  if (!hasDockerfile) {
    recommendations.push('Ajoutez un Dockerfile à la racine du projet');
  }
  if (!hasHealthcheck) {
    recommendations.push('Ajoutez un endpoint /health pour le monitoring');
  }
  if (proprietaryRuntimes.length > 0) {
    recommendations.push(`Remplacez les runtimes propriétaires: ${proprietaryRuntimes.join(', ')}`);
  }
  if (missingEnvVars.length > 0 && missingEnvVars.length <= 5) {
    recommendations.push(`Documentez ces variables dans .env.example: ${missingEnvVars.join(', ')}`);
  }
  
  return {
    ready: score >= 70 && proprietaryRuntimes.length === 0,
    score,
    checks: {
      dockerfile: { passed: hasDockerfile && dockerfileIssues.length === 0, issues: dockerfileIssues },
      dependencies: { passed: missingDeps.length === 0, missing: missingDeps },
      envVars: { passed: missingEnvVars.length === 0, required: Array.from(envVarsFound), missing: missingEnvVars },
      ports: { passed: ports.length > 0, exposed: ports },
      healthcheck: { passed: hasHealthcheck, path: hasHealthcheck ? '/health' : undefined },
      noProprietaryRuntime: { passed: proprietaryRuntimes.length === 0, found: proprietaryRuntimes },
    },
    recommendations,
  };
}

// ============================================
// NCS PHASE 7: CODE NORMALIZATION CONFIG
// ============================================

export const PRETTIER_CONFIG = `{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 100,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "avoid",
  "endOfLine": "lf"
}`;

export const ESLINT_CONFIG = `module.exports = {
  root: true,
  env: {
    browser: true,
    es2021: true,
    node: true,
  },
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'prettier',
  ],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaFeatures: { jsx: true },
    ecmaVersion: 'latest',
    sourceType: 'module',
  },
  plugins: ['react', '@typescript-eslint', 'react-hooks'],
  settings: {
    react: { version: 'detect' },
  },
  rules: {
    'react/react-in-jsx-scope': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
    'no-console': ['warn', { allow: ['warn', 'error'] }],
    'no-unused-vars': 'off',
    '@typescript-eslint/no-unused-vars': ['warn', { argsIgnorePattern: '^_' }],
  },
};`;

export const LINT_FIX_SCRIPT = `#!/bin/bash
# Lint & Format Script - Generated by InoPay Liberation Pack

echo "🔧 Running ESLint..."
npx eslint --fix src/ --ext .ts,.tsx,.js,.jsx

echo "✨ Running Prettier..."
npx prettier --write "src/**/*.{ts,tsx,js,jsx,css,json}"

echo "✅ Lint & format complete!"
`;

// ============================================
// NCS PHASE 8: REWRITE LOG GENERATOR
// ============================================

export interface RewriteLogEntry {
  file: string;
  changes: string[];
  linesChanged: number;
  timestamp: string;
}

export interface RewriteLog {
  version: string;
  generatedAt: string;
  projectName: string;
  totalFilesProcessed: number;
  totalFilesModified: number;
  totalChanges: number;
  entries: RewriteLogEntry[];
}

export function createRewriteLog(
  projectName: string,
  entries: RewriteLogEntry[]
): RewriteLog {
  return {
    version: '1.0',
    generatedAt: new Date().toISOString(),
    projectName,
    totalFilesProcessed: entries.length,
    totalFilesModified: entries.filter(e => e.changes.length > 0).length,
    totalChanges: entries.reduce((sum, e) => sum + e.changes.length, 0),
    entries,
  };
}

// ============================================
// NCS PHASE 9: FINAL SOVEREIGNTY PURGE
// Nettoie TOUTES les mentions textuelles restantes
// ============================================

/**
 * PURGE FINALE DE SOUVERAINETÉ
 * Nettoie toutes les mentions textuelles de plateformes IA, 
 * télémétrie, et services cloud propriétaires dans les strings et identifiants
 */
export function purgeProprietaryMentions(content: string, filePath: string): {
  cleaned: string;
  purgedPatterns: string[];
  wasModified: boolean;
} {
  const purgedPatterns: string[] = [];
  let cleaned = content;
  const originalContent = content;

  // === CATÉGORIE 1: Mentions de plateformes IA (dans les strings) ===
  const aiPlatformMentions = [
    // Lovable/GPTEngineer - mentions textuelles SEULEMENT dans strings/comments
    { pattern: /(['"`])([^'"`]*)\blovable\b([^'"`]*)\1/gi, replacement: '$1$2[PLATFORM]$3$1', name: 'lovable mention' },
    { pattern: /(['"`])([^'"`]*)\bgptengineer\b([^'"`]*)\1/gi, replacement: '$1$2[PLATFORM]$3$1', name: 'gptengineer mention' },
    { pattern: /(['"`])([^'"`]*)\bbolt\.new\b([^'"`]*)\1/gi, replacement: '$1$2[PLATFORM]$3$1', name: 'bolt.new mention' },
    // IA Cloud providers - mentions textuelles
    { pattern: /(['"`])([^'"`]*)\bopenai\b([^'"`]*)\1/gi, replacement: '$1$2[AI_PROVIDER]$3$1', name: 'openai mention' },
    { pattern: /(['"`])([^'"`]*)\banthropic\b([^'"`]*)\1/gi, replacement: '$1$2[AI_PROVIDER]$3$1', name: 'anthropic mention' },
    { pattern: /(['"`])([^'"`]*)\bclaude\b([^'"`]*)\1/gi, replacement: '$1$2[AI_MODEL]$3$1', name: 'claude mention' },
    { pattern: /(['"`])([^'"`]*)\bgpt-4\b([^'"`]*)\1/gi, replacement: '$1$2[AI_MODEL]$3$1', name: 'gpt-4 mention' },
    { pattern: /(['"`])([^'"`]*)\bgpt-5\b([^'"`]*)\1/gi, replacement: '$1$2[AI_MODEL]$3$1', name: 'gpt-5 mention' },
    // Assistants IA
    { pattern: /(['"`])([^'"`]*)\bcopilot\b([^'"`]*)\1/gi, replacement: '$1$2[ASSISTANT]$3$1', name: 'copilot mention' },
    { pattern: /(['"`])([^'"`]*)\btabnine\b([^'"`]*)\1/gi, replacement: '$1$2[ASSISTANT]$3$1', name: 'tabnine mention' },
    { pattern: /(['"`])([^'"`]*)\bcodeium\b([^'"`]*)\1/gi, replacement: '$1$2[ASSISTANT]$3$1', name: 'codeium mention' },
    { pattern: /(['"`])([^'"`]*)\bwindsurf\b([^'"`]*)\1/gi, replacement: '$1$2[ASSISTANT]$3$1', name: 'windsurf mention' },
    // SDKs IA
    { pattern: /(['"`])([^'"`]*)\bai-sdk\b([^'"`]*)\1/gi, replacement: '$1$2[SDK]$3$1', name: 'ai-sdk mention' },
    { pattern: /(['"`])([^'"`]*)\breplicate\b([^'"`]*)\1/gi, replacement: '$1$2[SDK]$3$1', name: 'replicate mention' },
    { pattern: /(['"`])([^'"`]*)\bhuggingface\b([^'"`]*)\1/gi, replacement: '$1$2[SDK]$3$1', name: 'huggingface mention' },
  ];

  // Appliquer SEULEMENT si ce n'est pas un fichier de config/pattern
  const isConfigFile = filePath.includes('proprietary') || 
                       filePath.includes('patterns') || 
                       filePath.includes('config.') ||
                       filePath.includes('.config.');
  
  if (!isConfigFile) {
    for (const { pattern, replacement, name } of aiPlatformMentions) {
      const before = cleaned;
      cleaned = cleaned.replace(pattern, replacement);
      if (cleaned !== before) {
        purgedPatterns.push(name);
      }
    }
  }

  // === CATÉGORIE 2: Télémétrie et tracking ===
  const telemetryPatterns = [
    // Appels télémétrie explicites
    { pattern: /telemetry\s*\.\s*track\s*\([^)]*\)/gi, replacement: '/* REMOVED: telemetry */', name: 'telemetry.track' },
    { pattern: /analytics\s*\.\s*track\s*\([^)]*\)/gi, replacement: '/* REMOVED: analytics */', name: 'analytics.track' },
    { pattern: /sendAnalytics\s*\([^)]*\)/gi, replacement: '/* REMOVED: sendAnalytics */', name: 'sendAnalytics' },
    { pattern: /trackEvent\s*\([^)]*\)/gi, replacement: '/* REMOVED: trackEvent */', name: 'trackEvent' },
    // Objets télémétrie
    { pattern: /const\s+telemetry\s*=\s*\{[\s\S]*?\};/g, replacement: '/* REMOVED: telemetry config */', name: 'telemetry object' },
    { pattern: /const\s+analytics\s*=\s*\{[\s\S]*?\};/g, replacement: '/* REMOVED: analytics config */', name: 'analytics object' },
    // Imports télémétrie
    { pattern: /import\s*{\s*[^}]*telemetry[^}]*}\s*from\s*['"][^'"]+['"]\s*;?\n?/gi, replacement: '', name: 'telemetry import' },
  ];

  for (const { pattern, replacement, name } of telemetryPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, replacement);
    if (cleaned !== before) {
      purgedPatterns.push(name);
    }
  }

  // === CATÉGORIE 3: Variables et constantes avec noms propriétaires ===
  const proprietaryIdentifiers = [
    // Variables avec "lovable" dans le nom
    { pattern: /const\s+\w*[Ll]ovable\w*\s*=/g, replacement: 'const _RENAMED_ =', name: 'lovable variable' },
    { pattern: /let\s+\w*[Ll]ovable\w*\s*=/g, replacement: 'let _RENAMED_ =', name: 'lovable variable' },
    { pattern: /var\s+\w*[Ll]ovable\w*\s*=/g, replacement: 'var _RENAMED_ =', name: 'lovable variable' },
    // Fonctions avec "lovable" dans le nom
    { pattern: /function\s+\w*[Ll]ovable\w*\s*\(/g, replacement: 'function _renamedFn(', name: 'lovable function' },
    // Types avec "lovable" dans le nom
    { pattern: /interface\s+\w*[Ll]ovable\w*/g, replacement: 'interface IRenamedType', name: 'lovable interface' },
    { pattern: /type\s+\w*[Ll]ovable\w*\s*=/g, replacement: 'type RenamedType =', name: 'lovable type' },
  ];

  if (!isConfigFile) {
    for (const { pattern, replacement, name } of proprietaryIdentifiers) {
      const before = cleaned;
      cleaned = cleaned.replace(pattern, replacement);
      if (cleaned !== before) {
        purgedPatterns.push(name);
      }
    }
  }

  // === CATÉGORIE 4: URLs et domaines propriétaires dans le code ===
  const proprietaryUrls = [
    // URLs Lovable
    { pattern: /https?:\/\/[a-z0-9-]+\.lovableproject\.com[^\s'"`]*/gi, replacement: 'https://your-domain.com', name: 'lovableproject URL' },
    { pattern: /https?:\/\/[a-z0-9-]+\.lovable\.(app|dev)[^\s'"`]*/gi, replacement: 'https://your-domain.com', name: 'lovable URL' },
    { pattern: /https?:\/\/[a-z0-9-]+\.gptengineer\.(app|run)[^\s'"`]*/gi, replacement: 'https://your-domain.com', name: 'gptengineer URL' },
    // API endpoints AI
    { pattern: /https?:\/\/api\.openai\.com[^\s'"`]*/gi, replacement: '${OLLAMA_BASE_URL}/api', name: 'OpenAI API URL' },
    { pattern: /https?:\/\/api\.anthropic\.com[^\s'"`]*/gi, replacement: '${OLLAMA_BASE_URL}/api', name: 'Anthropic API URL' },
    // Gateway Lovable AI
    { pattern: /https?:\/\/ai\.gateway\.lovable\.dev[^\s'"`]*/gi, replacement: '${OLLAMA_BASE_URL}/api', name: 'Lovable AI Gateway' },
  ];

  for (const { pattern, replacement, name } of proprietaryUrls) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, replacement);
    if (cleaned !== before) {
      purgedPatterns.push(name);
    }
  }

  // === CATÉGORIE 5: Clés API et secrets hardcodés ===
  const hardcodedSecrets = [
    // OpenAI API keys
    { pattern: /sk-[a-zA-Z0-9]{20,}/g, replacement: 'YOUR_OPENAI_KEY', name: 'OpenAI API key' },
    // Anthropic API keys
    { pattern: /sk-ant-[a-zA-Z0-9-]{20,}/g, replacement: 'YOUR_ANTHROPIC_KEY', name: 'Anthropic API key' },
    // Replicate tokens
    { pattern: /r8_[a-zA-Z0-9]{30,}/g, replacement: 'YOUR_REPLICATE_TOKEN', name: 'Replicate token' },
    // HuggingFace tokens
    { pattern: /hf_[a-zA-Z0-9]{30,}/g, replacement: 'YOUR_HUGGINGFACE_TOKEN', name: 'HuggingFace token' },
    // Lovable API keys
    { pattern: /lov_[a-zA-Z0-9]{20,}/g, replacement: 'YOUR_API_KEY', name: 'Lovable API key' },
    // Generic API key patterns
    { pattern: /LOVABLE_API_KEY/g, replacement: 'AI_API_KEY', name: 'LOVABLE_API_KEY env var' },
  ];

  for (const { pattern, replacement, name } of hardcodedSecrets) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, replacement);
    if (cleaned !== before) {
      purgedPatterns.push(name);
    }
  }

  // === CATÉGORIE 6: Commentaires avec mentions propriétaires ===
  const proprietaryComments = [
    // Commentaires mentionnant des plateformes
    { pattern: /\/\/\s*[^\n]*\b(lovable|gptengineer|bolt\.new)\b[^\n]*\n/gi, replacement: '', name: 'platform comment' },
    { pattern: /\/\*[\s\S]*?\b(lovable|gptengineer)\b[\s\S]*?\*\//gi, replacement: '', name: 'platform block comment' },
    // Commentaires "powered by"
    { pattern: /\/\/\s*[Pp]owered by[^\n]*\n/g, replacement: '', name: 'powered by comment' },
    { pattern: /\/\/\s*[Bb]uilt with[^\n]*\n/g, replacement: '', name: 'built with comment' },
    { pattern: /\/\/\s*[Mm]ade with[^\n]*\n/g, replacement: '', name: 'made with comment' },
    { pattern: /\/\/\s*[Cc]reated with[^\n]*\n/g, replacement: '', name: 'created with comment' },
    { pattern: /\/\/\s*[Gg]enerated by[^\n]*\n/g, replacement: '', name: 'generated by comment' },
  ];

  for (const { pattern, replacement, name } of proprietaryComments) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, replacement);
    if (cleaned !== before) {
      purgedPatterns.push(name);
    }
  }

  // === CATÉGORIE 7: Imports de SDKs propriétaires ===
  const proprietaryImports = [
    // AI SDKs
    { pattern: /import\s+[^;]*from\s*['"]openai['"]\s*;?\n?/g, replacement: '// REMOVED: OpenAI import - use Ollama\n', name: 'openai import' },
    { pattern: /import\s+[^;]*from\s*['"]@anthropic-ai\/sdk['"]\s*;?\n?/g, replacement: '// REMOVED: Anthropic import - use Ollama\n', name: 'anthropic import' },
    { pattern: /import\s+[^;]*from\s*['"]replicate['"]\s*;?\n?/g, replacement: '// REMOVED: Replicate import - use local models\n', name: 'replicate import' },
    { pattern: /import\s+[^;]*from\s*['"]@huggingface\/inference['"]\s*;?\n?/g, replacement: '// REMOVED: HuggingFace import - use local models\n', name: 'huggingface import' },
    { pattern: /import\s+[^;]*from\s*['"]ai['"]\s*;?\n?/g, replacement: '// REMOVED: ai-sdk import - use fetch\n', name: 'ai-sdk import' },
    // Lovable gateway
    { pattern: /import\s+[^;]*from\s*['"]@lovable\/[^'"]*['"]\s*;?\n?/g, replacement: '', name: '@lovable import' },
  ];

  for (const { pattern, replacement, name } of proprietaryImports) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, replacement);
    if (cleaned !== before) {
      purgedPatterns.push(name);
    }
  }

  // === Nettoyage final: lignes vides multiples ===
  cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
  cleaned = cleaned.replace(/^\s*\/\/ REMOVED:[^\n]*\n(\s*\/\/ REMOVED:[^\n]*\n)+/gm, '// REMOVED: multiple proprietary imports\n');

  return {
    cleaned,
    purgedPatterns,
    wasModified: cleaned !== originalContent
  };
}

/**
 * Exécute la purge finale sur tous les fichiers source
 */
export function executeFinalSovereigntyPurge(files: Record<string, string>): {
  cleanedFiles: Record<string, string>;
  purgeReport: { file: string; patterns: string[] }[];
  totalPatternsPurged: number;
} {
  const cleanedFiles: Record<string, string> = {};
  const purgeReport: { file: string; patterns: string[] }[] = [];
  let totalPatternsPurged = 0;

  for (const [filePath, content] of Object.entries(files)) {
    // Ignorer les fichiers binaires et certains fichiers de config
    if (
      filePath.endsWith('.png') || 
      filePath.endsWith('.jpg') || 
      filePath.endsWith('.ico') ||
      filePath.endsWith('.woff') ||
      filePath.endsWith('.woff2') ||
      filePath.includes('node_modules/') ||
      filePath.includes('.git/')
    ) {
      cleanedFiles[filePath] = content;
      continue;
    }

    // Appliquer la purge finale
    const result = purgeProprietaryMentions(content, filePath);
    cleanedFiles[filePath] = result.cleaned;

    if (result.purgedPatterns.length > 0) {
      purgeReport.push({ file: filePath, patterns: result.purgedPatterns });
      totalPatternsPurged += result.purgedPatterns.length;
    }
  }

  return { cleanedFiles, purgeReport, totalPatternsPurged };
}
