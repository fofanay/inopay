/**
 * LOVABLE CLEANER ENGINE
 * ======================
 * Module de nettoyage de code Lovable
 * Prend le rÃ©sultat du scanner et produit un projet propre
 * 
 * FonctionnalitÃ©s:
 * - Suppression des importations propriÃ©taires
 * - Remplacement des patterns Lovable
 * - Correction des dÃ©pendances
 * - Propositions de rÃ©Ã©critures autonomes
 * 
 * Â© 2024 Inovaq Canada Inc.
 */

import type { ScanResult, ScanIssue } from './lovablePatternScanner';

// ============= TYPES =============

export interface CleaningOptions {
  removeImports: boolean;
  replacePatterns: boolean;
  fixDependencies: boolean;
  generatePolyfills: boolean;
  preserveComments: boolean;
  dryRun: boolean;
}

export interface FileCleaningResult {
  filePath: string;
  originalContent: string;
  cleanedContent: string;
  wasModified: boolean;
  wasRemoved: boolean;
  changes: Change[];
  rewrites: Rewrite[];
}

export interface Change {
  type: 'removed' | 'replaced' | 'added';
  line: number;
  column: number;
  original: string;
  replacement: string;
  reason: string;
}

export interface Rewrite {
  type: 'import' | 'pattern' | 'dependency' | 'function' | 'component';
  original: string;
  suggested: string;
  description: string;
  autoApplicable: boolean;
}

export interface CleaningReport {
  totalFiles: number;
  filesModified: number;
  filesRemoved: number;
  filesUnchanged: number;
  totalChanges: number;
  totalRewrites: number;
  results: Map<string, FileCleaningResult>;
  cleanedFiles: Record<string, string>;
  packageJsonPatches: PackageJsonPatch[];
  summary: CleaningSummary;
}

export interface CleaningSummary {
  importsRemoved: number;
  patternsReplaced: number;
  dependenciesFixed: number;
  polyfillsGenerated: number;
  estimatedTimeSaved: number; // en minutes
}

export interface PackageJsonPatch {
  action: 'remove' | 'replace' | 'add';
  package: string;
  originalVersion?: string;
  newPackage?: string;
  newVersion?: string;
  reason: string;
}

// ============= REPLACEMENT MAPS =============

/**
 * Map des imports Lovable -> alternatives souveraines
 */
const IMPORT_REPLACEMENTS: Record<string, { replacement: string; description: string }> = {
  // Lovable imports
  '@lovable/core': { 
    replacement: '', 
    description: 'Supprimer - fonctionnalitÃ© non nÃ©cessaire' 
  },
  '@lovable/ui': { 
    replacement: '@radix-ui/react-*', 
    description: 'Utiliser Radix UI directement' 
  },
  'lovable-tagger': { 
    replacement: '', 
    description: 'Supprimer - outil de debug Lovable' 
  },
  
  // Supabase integrations (auto-generated by Lovable)
  '@/integrations/supabase/client': { 
    replacement: '@supabase/supabase-js', 
    description: 'Import direct Supabase' 
  },
  '@/integrations/supabase/types': { 
    replacement: './types/database.ts', 
    description: 'Types locaux gÃ©nÃ©rÃ©s' 
  },
  
  // Agent imports
  '@agent/': { 
    replacement: '', 
    description: 'Supprimer - agent Lovable' 
  },
  
  // AI SDK replacements
  '@anthropic-ai/sdk': { 
    replacement: '@/lib/unifiedLLM', 
    description: 'Utiliser UnifiedLLM souverain' 
  },
  'openai': { 
    replacement: '@/lib/unifiedLLM', 
    description: 'Utiliser UnifiedLLM souverain' 
  },
};

/**
 * Map des patterns Lovable -> code souverain
 */
const PATTERN_REPLACEMENTS: Array<{
  pattern: RegExp;
  replacement: string | ((match: string, ...groups: string[]) => string);
  description: string;
}> = [
  // lovable.generate -> UnifiedLLM
  {
    pattern: /lovable\.generate\s*\(\s*(['"`])([^'"`]+)\1\s*\)/g,
    replacement: (_, quote, prompt) => `unifiedLLM.complete(${quote}${prompt}${quote})`,
    description: 'Remplacement par UnifiedLLM.complete()'
  },
  
  // lovableApi calls
  {
    pattern: /lovableApi\.(chat|complete|generate)\s*\(/g,
    replacement: 'unifiedLLM.$1(',
    description: 'Remplacement par UnifiedLLM'
  },
  
  // getAIAssistant
  {
    pattern: /getAIAssistant\s*\(\s*\)/g,
    replacement: 'new UnifiedLLM({ provider: "ollama" })',
    description: 'Remplacement par instance UnifiedLLM'
  },
  
  // runAssistant
  {
    pattern: /runAssistant\s*\(\s*([^)]+)\s*\)/g,
    replacement: 'await unifiedLLM.chat($1)',
    description: 'Remplacement par UnifiedLLM.chat()'
  },
  
  // EventSchema usage
  {
    pattern: /EventSchema\.(\w+)/g,
    replacement: (_, schemaName) => `z.object({ /* ${schemaName} schema */ })`,
    description: 'Remplacement par schÃ©ma Zod local'
  },
  
  // Pattern.* usage  
  {
    pattern: /Pattern\.(\w+)/g,
    replacement: (_, patternName) => `PATTERNS.${patternName}`,
    description: 'Remplacement par patterns locaux'
  },
  
  // Data attributes Lovable
  {
    pattern: /\s*data-lov-[a-z-]+="[^"]*"/g,
    replacement: '',
    description: 'Suppression attributs Lovable'
  },
  
  // Lovable comments
  {
    pattern: /\/\/\s*@lovable[^\n]*/g,
    replacement: '',
    description: 'Suppression commentaires Lovable'
  },
  {
    pattern: /\/\/\s*Generated by Lovable[^\n]*/gi,
    replacement: '',
    description: 'Suppression commentaires gÃ©nÃ©ration'
  },
  
  // Supabase project URLs (hardcoded)
  {
    pattern: /https:\/\/[a-z]{20}\.supabase\.co/g,
    replacement: 'process.env.SUPABASE_URL',
    description: 'Remplacement par variable d\'environnement'
  },
  
  // Telemetry fetch calls
  {
    pattern: /fetch\s*\(\s*['"][^'"]*lovable[^'"]*['"]\s*[,)]/gi,
    replacement: '/* Telemetry removed */',
    description: 'Suppression appel tÃ©lÃ©mÃ©trie'
  },
  
  // Navigator beacon
  {
    pattern: /navigator\.sendBeacon\s*\([^)]*lovable[^)]*\)\s*;?/gi,
    replacement: '/* Beacon removed */',
    description: 'Suppression beacon tÃ©lÃ©mÃ©trie'
  },
  
  // Environment variables
  {
    pattern: /VITE_LOVABLE_[A-Z_]+/g,
    replacement: 'VITE_APP_CONFIG',
    description: 'Remplacement variable Lovable'
  },
];

/**
 * Map des dÃ©pendances -> alternatives
 */
const DEPENDENCY_REPLACEMENTS: Record<string, PackageJsonPatch> = {
  'lovable-tagger': {
    action: 'remove',
    package: 'lovable-tagger',
    reason: 'Outil de debug Lovable - non nÃ©cessaire en production'
  },
  '@lovable/core': {
    action: 'remove',
    package: '@lovable/core',
    reason: 'SDK Lovable - remplacÃ© par code local'
  },
  '@lovable/ui': {
    action: 'replace',
    package: '@lovable/ui',
    newPackage: '@radix-ui/react-primitive',
    newVersion: '^1.0.0',
    reason: 'Remplacement par Radix UI'
  },
  'openai': {
    action: 'replace',
    package: 'openai',
    newPackage: 'ollama',
    newVersion: '^0.5.0',
    reason: 'Remplacement par Ollama SDK'
  },
  '@anthropic-ai/sdk': {
    action: 'remove',
    package: '@anthropic-ai/sdk',
    reason: 'RemplacÃ© par UnifiedLLM souverain'
  },
};

// ============= CLEANER ENGINE CLASS =============

export class LovableCleanerEngine {
  private options: CleaningOptions;
  
  constructor(options?: Partial<CleaningOptions>) {
    this.options = {
      removeImports: true,
      replacePatterns: true,
      fixDependencies: true,
      generatePolyfills: true,
      preserveComments: false,
      dryRun: false,
      ...options
    };
  }
  
  /**
   * Nettoie un projet complet Ã  partir du rÃ©sultat du scanner
   */
  cleanProject(
    files: Record<string, string>,
    scanResult: ScanResult
  ): CleaningReport {
    const results = new Map<string, FileCleaningResult>();
    const cleanedFiles: Record<string, string> = {};
    const packageJsonPatches: PackageJsonPatch[] = [];
    
    let filesModified = 0;
    let filesRemoved = 0;
    let filesUnchanged = 0;
    let totalChanges = 0;
    let totalRewrites = 0;
    
    const summary: CleaningSummary = {
      importsRemoved: 0,
      patternsReplaced: 0,
      dependenciesFixed: 0,
      polyfillsGenerated: 0,
      estimatedTimeSaved: 0
    };
    
    // Nettoyer chaque fichier
    for (const [filePath, content] of Object.entries(files)) {
      // Ignorer node_modules et fichiers binaires
      if (this.shouldSkipFile(filePath)) {
        cleanedFiles[filePath] = content;
        filesUnchanged++;
        continue;
      }
      
      // Trouver les issues pour ce fichier
      const fileIssues = scanResult.issues.filter(i => i.file === filePath);
      
      // Nettoyer le fichier
      const result = this.cleanFile(filePath, content, fileIssues);
      results.set(filePath, result);
      
      if (result.wasRemoved) {
        filesRemoved++;
      } else if (result.wasModified) {
        filesModified++;
        cleanedFiles[filePath] = result.cleanedContent;
      } else {
        filesUnchanged++;
        cleanedFiles[filePath] = content;
      }
      
      totalChanges += result.changes.length;
      totalRewrites += result.rewrites.length;
      
      // Compter les types de changements
      for (const change of result.changes) {
        if (change.reason.includes('import')) summary.importsRemoved++;
        if (change.reason.includes('pattern') || change.reason.includes('replacement')) summary.patternsReplaced++;
      }
      
      // Traitement spÃ©cial pour package.json
      if (filePath === 'package.json' || filePath.endsWith('/package.json')) {
        const patches = this.generatePackagePatches(content);
        packageJsonPatches.push(...patches);
        summary.dependenciesFixed += patches.length;
        
        // Appliquer les patches
        if (!this.options.dryRun && this.options.fixDependencies) {
          const patchedContent = this.applyPackagePatches(content, patches);
          cleanedFiles[filePath] = patchedContent;
        }
      }
    }
    
    // GÃ©nÃ©rer les polyfills si nÃ©cessaire
    if (this.options.generatePolyfills) {
      const polyfills = this.generatePolyfills(scanResult);
      for (const [path, content] of Object.entries(polyfills)) {
        cleanedFiles[path] = content;
        summary.polyfillsGenerated++;
      }
    }
    
    // Estimer le temps Ã©conomisÃ© (basÃ© sur le nombre de changements)
    summary.estimatedTimeSaved = Math.ceil((totalChanges * 0.5) + (totalRewrites * 2));
    
    return {
      totalFiles: Object.keys(files).length,
      filesModified,
      filesRemoved,
      filesUnchanged,
      totalChanges,
      totalRewrites,
      results,
      cleanedFiles,
      packageJsonPatches,
      summary
    };
  }
  
  /**
   * Nettoie un fichier individuel
   */
  cleanFile(
    filePath: string, 
    content: string, 
    issues: ScanIssue[] = []
  ): FileCleaningResult {
    const changes: Change[] = [];
    const rewrites: Rewrite[] = [];
    let cleanedContent = content;
    let wasModified = false;
    let wasRemoved = false;
    
    // VÃ©rifier si le fichier doit Ãªtre supprimÃ©
    if (this.shouldRemoveFile(filePath)) {
      return {
        filePath,
        originalContent: content,
        cleanedContent: '',
        wasModified: true,
        wasRemoved: true,
        changes: [{
          type: 'removed',
          line: 1,
          column: 1,
          original: content,
          replacement: '',
          reason: 'Fichier propriÃ©taire supprimÃ©'
        }],
        rewrites: []
      };
    }
    
    // Phase 1: Supprimer les imports propriÃ©taires
    if (this.options.removeImports) {
      const importResult = this.cleanImports(cleanedContent, filePath);
      if (importResult.modified) {
        cleanedContent = importResult.content;
        changes.push(...importResult.changes);
        rewrites.push(...importResult.rewrites);
        wasModified = true;
      }
    }
    
    // Phase 2: Remplacer les patterns Lovable
    if (this.options.replacePatterns) {
      const patternResult = this.replacePatterns(cleanedContent, filePath);
      if (patternResult.modified) {
        cleanedContent = patternResult.content;
        changes.push(...patternResult.changes);
        rewrites.push(...patternResult.rewrites);
        wasModified = true;
      }
    }
    
    // Phase 3: Nettoyer les lignes vides consÃ©cutives
    const originalLines = cleanedContent.split('\n').length;
    cleanedContent = this.cleanEmptyLines(cleanedContent);
    if (cleanedContent.split('\n').length !== originalLines) {
      wasModified = true;
    }
    
    return {
      filePath,
      originalContent: content,
      cleanedContent,
      wasModified,
      wasRemoved,
      changes,
      rewrites
    };
  }
  
  // ============= PRIVATE METHODS =============
  
  /**
   * Nettoie les imports d'un fichier
   */
  private cleanImports(content: string, filePath: string): {
    content: string;
    modified: boolean;
    changes: Change[];
    rewrites: Rewrite[];
  } {
    const lines = content.split('\n');
    const cleanedLines: string[] = [];
    const changes: Change[] = [];
    const rewrites: Rewrite[] = [];
    let modified = false;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      let shouldKeep = true;
      let replacementLine = line;
      
      // VÃ©rifier chaque pattern d'import
      for (const [importPattern, replacement] of Object.entries(IMPORT_REPLACEMENTS)) {
        if (line.includes(importPattern)) {
          if (replacement.replacement === '') {
            // Supprimer la ligne
            shouldKeep = false;
            changes.push({
              type: 'removed',
              line: i + 1,
              column: 1,
              original: line,
              replacement: '',
              reason: `Import propriÃ©taire supprimÃ©: ${importPattern}`
            });
          } else {
            // Remplacer l'import
            replacementLine = line.replace(importPattern, replacement.replacement);
            changes.push({
              type: 'replaced',
              line: i + 1,
              column: line.indexOf(importPattern) + 1,
              original: line,
              replacement: replacementLine,
              reason: `Import remplacÃ©: ${replacement.description}`
            });
            
            rewrites.push({
              type: 'import',
              original: importPattern,
              suggested: replacement.replacement,
              description: replacement.description,
              autoApplicable: true
            });
          }
          modified = true;
          break;
        }
      }
      
      if (shouldKeep) {
        cleanedLines.push(replacementLine);
      }
    }
    
    return {
      content: cleanedLines.join('\n'),
      modified,
      changes,
      rewrites
    };
  }
  
  /**
   * Remplace les patterns Lovable
   */
  private replacePatterns(content: string, filePath: string): {
    content: string;
    modified: boolean;
    changes: Change[];
    rewrites: Rewrite[];
  } {
    let cleanedContent = content;
    const changes: Change[] = [];
    const rewrites: Rewrite[] = [];
    let modified = false;
    
    for (const patternDef of PATTERN_REPLACEMENTS) {
      // Reset regex
      patternDef.pattern.lastIndex = 0;
      
      let match: RegExpExecArray | null;
      const matches: Array<{ index: number; text: string }> = [];
      
      // Collecter tous les matches d'abord
      while ((match = patternDef.pattern.exec(content)) !== null) {
        matches.push({ index: match.index, text: match[0] });
      }
      
      if (matches.length > 0) {
        modified = true;
        
        // Appliquer le remplacement
        if (typeof patternDef.replacement === 'function') {
          cleanedContent = cleanedContent.replace(patternDef.pattern, patternDef.replacement as any);
        } else {
          cleanedContent = cleanedContent.replace(patternDef.pattern, patternDef.replacement);
        }
        
        // Enregistrer les changements
        for (const m of matches) {
          const { line, column } = this.getLineAndColumn(content, m.index);
          changes.push({
            type: 'replaced',
            line,
            column,
            original: m.text,
            replacement: typeof patternDef.replacement === 'string' ? patternDef.replacement : '[computed]',
            reason: patternDef.description
          });
        }
        
        rewrites.push({
          type: 'pattern',
          original: patternDef.pattern.source,
          suggested: typeof patternDef.replacement === 'string' ? patternDef.replacement : '[function]',
          description: patternDef.description,
          autoApplicable: true
        });
      }
    }
    
    return {
      content: cleanedContent,
      modified,
      changes,
      rewrites
    };
  }
  
  /**
   * GÃ©nÃ¨re les patches pour package.json
   */
  private generatePackagePatches(content: string): PackageJsonPatch[] {
    const patches: PackageJsonPatch[] = [];
    
    try {
      const pkg = JSON.parse(content);
      const allDeps = {
        ...pkg.dependencies,
        ...pkg.devDependencies
      };
      
      for (const [dep, version] of Object.entries(allDeps)) {
        if (DEPENDENCY_REPLACEMENTS[dep]) {
          const patch = { ...DEPENDENCY_REPLACEMENTS[dep] };
          patch.originalVersion = version as string;
          patches.push(patch);
        }
      }
    } catch {
      // JSON invalide
    }
    
    return patches;
  }
  
  /**
   * Applique les patches au package.json
   */
  private applyPackagePatches(content: string, patches: PackageJsonPatch[]): string {
    try {
      const pkg = JSON.parse(content);
      
      for (const patch of patches) {
        // Supprimer des dependencies
        if (pkg.dependencies?.[patch.package]) {
          if (patch.action === 'remove') {
            delete pkg.dependencies[patch.package];
          } else if (patch.action === 'replace' && patch.newPackage) {
            delete pkg.dependencies[patch.package];
            pkg.dependencies[patch.newPackage] = patch.newVersion || '*';
          }
        }
        
        // Supprimer des devDependencies
        if (pkg.devDependencies?.[patch.package]) {
          if (patch.action === 'remove') {
            delete pkg.devDependencies[patch.package];
          } else if (patch.action === 'replace' && patch.newPackage) {
            delete pkg.devDependencies[patch.package];
            pkg.devDependencies[patch.newPackage] = patch.newVersion || '*';
          }
        }
      }
      
      return JSON.stringify(pkg, null, 2);
    } catch {
      return content;
    }
  }
  
  /**
   * GÃ©nÃ¨re les polyfills nÃ©cessaires
   */
  private generatePolyfills(scanResult: ScanResult): Record<string, string> {
    const polyfills: Record<string, string> = {};
    
    // VÃ©rifier si UnifiedLLM est nÃ©cessaire
    const needsUnifiedLLM = scanResult.issues.some(
      i => i.pattern === 'get-ai-assistant' || 
           i.pattern === 'run-assistant' ||
           i.pattern === 'lovable-generate' ||
           i.pattern === 'lovable-api'
    );
    
    if (needsUnifiedLLM) {
      polyfills['src/lib/unifiedLLM.ts'] = this.generateUnifiedLLMPolyfill();
    }
    
    // VÃ©rifier si des patterns locaux sont nÃ©cessaires
    const needsPatterns = scanResult.issues.some(
      i => i.pattern === 'pattern-usage' || i.pattern === 'event-schema'
    );
    
    if (needsPatterns) {
      polyfills['src/lib/patterns.ts'] = this.generatePatternsPolyfill();
    }
    
    // GÃ©nÃ©rer le fichier de types Supabase si nÃ©cessaire
    const needsSupabaseTypes = scanResult.issues.some(
      i => i.pattern === 'supabase-integration-import'
    );
    
    if (needsSupabaseTypes) {
      polyfills['src/types/database.ts'] = this.generateSupabaseTypesPolyfill();
    }
    
    return polyfills;
  }
  
  /**
   * GÃ©nÃ¨re le polyfill UnifiedLLM
   */
  private generateUnifiedLLMPolyfill(): string {
    return `/**
 * UnifiedLLM - Adaptateur IA souverain
 * GÃ©nÃ©rÃ© automatiquement par Inopay Liberator
 * Supporte: Ollama, LM Studio, OpenWebUI, APIs compatibles OpenAI
 */

export type AIProvider = 'ollama' | 'lmstudio' | 'openwebui' | 'openai-compatible';

export interface UnifiedLLMConfig {
  provider: AIProvider;
  baseUrl: string;
  model?: string;
  apiKey?: string;
}

export interface Message {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

export interface CompletionResponse {
  content: string;
  model: string;
  usage: {
    promptTokens: number;
    completionTokens: number;
  };
}

const DEFAULT_CONFIGS: Record<AIProvider, Partial<UnifiedLLMConfig>> = {
  ollama: { baseUrl: 'http://localhost:11434', model: 'llama3.2' },
  lmstudio: { baseUrl: 'http://localhost:1234', model: 'default' },
  openwebui: { baseUrl: 'http://localhost:3000', model: 'default' },
  'openai-compatible': { baseUrl: 'http://localhost:8080', model: 'gpt-3.5-turbo' }
};

export class UnifiedLLM {
  private config: UnifiedLLMConfig;

  constructor(config: Partial<UnifiedLLMConfig> = {}) {
    const provider = config.provider || 'ollama';
    this.config = {
      ...DEFAULT_CONFIGS[provider],
      ...config,
      provider
    } as UnifiedLLMConfig;
  }

  async complete(prompt: string): Promise<CompletionResponse> {
    return this.chat([{ role: 'user', content: prompt }]);
  }

  async chat(messages: Message[]): Promise<CompletionResponse> {
    const endpoint = this.getEndpoint();
    
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(this.config.apiKey ? { 'Authorization': \`Bearer \${this.config.apiKey}\` } : {})
      },
      body: JSON.stringify({
        model: this.config.model,
        messages,
        stream: false
      })
    });

    if (!response.ok) {
      throw new Error(\`AI request failed: \${response.statusText}\`);
    }

    const data = await response.json();
    
    return {
      content: data.choices?.[0]?.message?.content || data.message?.content || '',
      model: data.model || this.config.model || 'unknown',
      usage: {
        promptTokens: data.usage?.prompt_tokens || 0,
        completionTokens: data.usage?.completion_tokens || 0
      }
    };
  }

  async *stream(prompt: string): AsyncGenerator<string> {
    const endpoint = this.getEndpoint();
    
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(this.config.apiKey ? { 'Authorization': \`Bearer \${this.config.apiKey}\` } : {})
      },
      body: JSON.stringify({
        model: this.config.model,
        messages: [{ role: 'user', content: prompt }],
        stream: true
      })
    });

    if (!response.ok || !response.body) {
      throw new Error(\`AI stream failed: \${response.statusText}\`);
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunk = decoder.decode(value, { stream: true });
      const lines = chunk.split('\\n').filter(line => line.startsWith('data: '));

      for (const line of lines) {
        const json = line.slice(6);
        if (json === '[DONE]') return;
        
        try {
          const data = JSON.parse(json);
          const content = data.choices?.[0]?.delta?.content;
          if (content) yield content;
        } catch {
          // Ignore parse errors
        }
      }
    }
  }

  private getEndpoint(): string {
    switch (this.config.provider) {
      case 'ollama':
        return \`\${this.config.baseUrl}/api/chat\`;
      case 'lmstudio':
      case 'openwebui':
      case 'openai-compatible':
        return \`\${this.config.baseUrl}/v1/chat/completions\`;
      default:
        return \`\${this.config.baseUrl}/v1/chat/completions\`;
    }
  }
}

// Instance par dÃ©faut
export const unifiedLLM = new UnifiedLLM();
export default UnifiedLLM;
`;
  }
  
  /**
   * GÃ©nÃ¨re le polyfill des patterns
   */
  private generatePatternsPolyfill(): string {
    return `/**
 * PATTERNS - Patterns de dÃ©tection locaux
 * GÃ©nÃ©rÃ© automatiquement par Inopay Liberator
 * Remplace Pattern.* et EventSchema.*
 */

import { z } from 'zod';

// ============= PATTERNS =============

export const PATTERNS = {
  // Email pattern
  EMAIL: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/,
  
  // URL pattern
  URL: /^https?:\\/\\/[^\\s/$.?#].[^\\s]*$/,
  
  // UUID pattern
  UUID: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,
  
  // Phone pattern
  PHONE: /^\\+?[1-9]\\d{1,14}$/,
  
  // Slug pattern
  SLUG: /^[a-z0-9]+(?:-[a-z0-9]+)*$/,
  
  // IP Address pattern
  IP_ADDRESS: /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
};

// ============= EVENT SCHEMAS (Zod) =============

export const EventSchema = {
  // User event
  UserEvent: z.object({
    userId: z.string().uuid(),
    action: z.string(),
    timestamp: z.string().datetime(),
    metadata: z.record(z.unknown()).optional()
  }),
  
  // Error event
  ErrorEvent: z.object({
    code: z.string(),
    message: z.string(),
    stack: z.string().optional(),
    timestamp: z.string().datetime()
  }),
  
  // Analytics event
  AnalyticsEvent: z.object({
    event: z.string(),
    properties: z.record(z.unknown()),
    timestamp: z.string().datetime()
  }),
  
  // Notification event
  NotificationEvent: z.object({
    type: z.enum(['info', 'warning', 'error', 'success']),
    title: z.string(),
    message: z.string(),
    duration: z.number().optional()
  })
};

export default { PATTERNS, EventSchema };
`;
  }
  
  /**
   * GÃ©nÃ¨re le polyfill des types Supabase
   */
  private generateSupabaseTypesPolyfill(): string {
    return `/**
 * Database Types - Types Supabase locaux
 * GÃ©nÃ©rÃ© automatiquement par Inopay Liberator
 * 
 * IMPORTANT: RÃ©gÃ©nÃ©rez ces types avec votre schÃ©ma rÃ©el
 * Commande: npx supabase gen types typescript --local > src/types/database.ts
 */

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export interface Database {
  public: {
    Tables: {
      // Ajoutez vos tables ici
      // Exemple:
      // users: {
      //   Row: { id: string; email: string; created_at: string }
      //   Insert: { id?: string; email: string; created_at?: string }
      //   Update: { id?: string; email?: string; created_at?: string }
      // }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      [_ in never]: never
    }
    Enums: {
      [_ in never]: never
    }
  }
}

// Helper types
export type Tables<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Row']

export type InsertTables<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Insert']

export type UpdateTables<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Update']
`;
  }
  
  /**
   * VÃ©rifie si un fichier doit Ãªtre ignorÃ©
   */
  private shouldSkipFile(filePath: string): boolean {
    const skipPatterns = [
      'node_modules/',
      '.git/',
      'dist/',
      'build/',
      '.next/',
      '.cache/',
      '*.min.js',
      '*.min.css',
      '*.map',
      '*.lock',
      'package-lock.json',
      'bun.lockb'
    ];
    
    return skipPatterns.some(pattern => {
      if (pattern.startsWith('*')) {
        return filePath.endsWith(pattern.slice(1));
      }
      return filePath.includes(pattern);
    });
  }
  
  /**
   * VÃ©rifie si un fichier doit Ãªtre supprimÃ©
   */
  private shouldRemoveFile(filePath: string): boolean {
    const removePatterns = [
      '.lovable',
      'lovable.config',
      'lovable.json',
      '.bolt',
      'bolt.config',
      '.cursor',
      'cursor.config',
      '__lovable__',
      '.agent',
      'agent.config',
      'src/integrations/supabase/types.ts', // Auto-generated
      'src/integrations/supabase/client.ts' // Auto-generated
    ];
    
    const filename = filePath.split('/').pop() || '';
    return removePatterns.some(pattern => 
      filename.toLowerCase().includes(pattern.toLowerCase()) ||
      filePath.toLowerCase().includes(pattern.toLowerCase())
    );
  }
  
  /**
   * Nettoie les lignes vides consÃ©cutives
   */
  private cleanEmptyLines(content: string): string {
    return content.replace(/\n{3,}/g, '\n\n');
  }
  
  /**
   * Obtient la ligne et colonne Ã  partir d'un index
   */
  private getLineAndColumn(content: string, index: number): { line: number; column: number } {
    const lines = content.substring(0, index).split('\n');
    return {
      line: lines.length,
      column: lines[lines.length - 1].length + 1
    };
  }
}

// ============= UTILITY FUNCTIONS =============

/**
 * Fonction de nettoyage rapide
 */
export function quickClean(
  files: Record<string, string>,
  scanResult: ScanResult
): CleaningReport {
  const engine = new LovableCleanerEngine();
  return engine.cleanProject(files, scanResult);
}

/**
 * Formate le rapport de nettoyage
 */
export function formatCleaningReport(report: CleaningReport): string {
  const lines: string[] = [
    'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
    '           INOPAY CLEANER ENGINE REPORT                    ',
    'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
    '',
    `ğŸ“ Fichiers traitÃ©s: ${report.totalFiles}`,
    `âœï¸  Fichiers modifiÃ©s: ${report.filesModified}`,
    `ğŸ—‘ï¸  Fichiers supprimÃ©s: ${report.filesRemoved}`,
    `âœ… Fichiers inchangÃ©s: ${report.filesUnchanged}`,
    '',
    'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€',
    '                       RÃ‰SUMÃ‰                              ',
    'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€',
    `ğŸ“¦ Imports supprimÃ©s: ${report.summary.importsRemoved}`,
    `ğŸ”„ Patterns remplacÃ©s: ${report.summary.patternsReplaced}`,
    `ğŸ“‹ DÃ©pendances corrigÃ©es: ${report.summary.dependenciesFixed}`,
    `ğŸ”§ Polyfills gÃ©nÃ©rÃ©s: ${report.summary.polyfillsGenerated}`,
    `â±ï¸  Temps estimÃ© Ã©conomisÃ©: ${report.summary.estimatedTimeSaved} min`,
    '',
  ];
  
  if (report.packageJsonPatches.length > 0) {
    lines.push('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    lines.push('                 PATCHES PACKAGE.JSON                      ');
    lines.push('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    
    for (const patch of report.packageJsonPatches) {
      const icon = patch.action === 'remove' ? 'ğŸ—‘ï¸' : patch.action === 'replace' ? 'ğŸ”„' : 'â•';
      lines.push(`${icon} ${patch.action.toUpperCase()}: ${patch.package}`);
      if (patch.newPackage) {
        lines.push(`   â†’ ${patch.newPackage}@${patch.newVersion}`);
      }
      lines.push(`   ğŸ“ ${patch.reason}`);
    }
    lines.push('');
  }
  
  lines.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  lines.push('            GÃ©nÃ©rÃ© par Inopay Cleaner Engine               ');
  lines.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  
  return lines.join('\n');
}

// Default export
export default LovableCleanerEngine;
