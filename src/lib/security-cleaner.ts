/**
 * INOPAY SECURITY CLEANER
 * Utilitaires pour nettoyer le code des signatures IDE et dépendances propriétaires
 */

// Patterns à supprimer des fichiers source
export const SIGNATURE_PATTERNS = {
  // Attributs data-lovable-*
  dataLovableId: /\s*data-lovable-id="[^"]*"/gi,
  dataLovablePath: /\s*data-lovable-path="[^"]*"/gi,
  dataLovableComponent: /\s*data-lovable-component="[^"]*"/gi,
  dataLovable: /\s*data-lovable[^=]*="[^"]*"/gi,
  
  // Commentaires auto-générés
  lovableComment: /\/\*\s*@lovable[^*]*\*\//gi,
  lovableInlineComment: /\/\/\s*@lovable[^\n]*/gi,
  generatedComment: /\/\*\s*This file is automatically generated[^*]*\*\//gi,
  doNotEditComment: /\/\*\s*Do not edit it directly[^*]*\*\//gi,
  
  // Imports Lovable spécifiques
  lovableTaggerImport: /import\s*{?\s*componentTagger\s*}?\s*from\s*["']lovable-tagger["'];?\n?/gi,
  lovableTaggerUsage: /componentTagger\(\),?\s*/gi,
  
  // Commentaires Bolt/V0/Cursor
  boltComment: /\/\*\s*@bolt[^*]*\*\//gi,
  v0Comment: /\/\*\s*@v0[^*]*\*\//gi,
  cursorComment: /\/\*\s*@cursor[^*]*\*\//gi,
};

// Nettoyer le contenu d'un fichier
export const cleanFileContent = (content: string): string => {
  let cleaned = content;
  
  // Appliquer tous les patterns de nettoyage
  for (const pattern of Object.values(SIGNATURE_PATTERNS)) {
    cleaned = cleaned.replace(pattern, '');
  }
  
  // Nettoyer les lignes vides multiples
  cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
  
  // Nettoyer les espaces en fin de ligne
  cleaned = cleaned.replace(/[ \t]+$/gm, '');
  
  return cleaned;
};

// Nettoyer le DOM au runtime
export const cleanDOMSignatures = (): number => {
  let removedCount = 0;
  
  // Sélectionner tous les éléments avec des attributs data-lovable-*
  const elementsWithLovable = document.querySelectorAll('[data-lovable-id], [data-lovable-path], [data-lovable-component]');
  
  elementsWithLovable.forEach((element) => {
    // Supprimer tous les attributs data-lovable-*
    Array.from(element.attributes).forEach((attr) => {
      if (attr.name.startsWith('data-lovable')) {
        element.removeAttribute(attr.name);
        removedCount++;
      }
    });
  });
  
  return removedCount;
};

// Observer pour nettoyer les nouveaux éléments ajoutés au DOM
let cleanerObserver: MutationObserver | null = null;

export const startDOMCleaner = (): void => {
  if (cleanerObserver) return;
  
  cleanerObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.addedNodes.forEach((node) => {
        if (node instanceof HTMLElement) {
          // Nettoyer l'élément lui-même
          Array.from(node.attributes).forEach((attr) => {
            if (attr.name.startsWith('data-lovable')) {
              node.removeAttribute(attr.name);
            }
          });
          
          // Nettoyer les enfants
          const children = node.querySelectorAll('[data-lovable-id], [data-lovable-path], [data-lovable-component]');
          children.forEach((child) => {
            Array.from(child.attributes).forEach((attr) => {
              if (attr.name.startsWith('data-lovable')) {
                child.removeAttribute(attr.name);
              }
            });
          });
        }
      });
    });
  });
  
  cleanerObserver.observe(document.body, {
    childList: true,
    subtree: true,
  });
};

export const stopDOMCleaner = (): void => {
  if (cleanerObserver) {
    cleanerObserver.disconnect();
    cleanerObserver = null;
  }
};

// Dépendances propriétaires à remplacer
export const PROPRIETARY_DEPS: Record<string, { 
  replacement: string; 
  version: string;
  reason: string;
}> = {
  'lovable-tagger': {
    replacement: '',
    version: '',
    reason: 'IDE-specific, not needed in production',
  },
  '@lovable/ui': {
    replacement: '@radix-ui/react-*',
    version: 'latest',
    reason: 'Lovable-specific UI wrapper',
  },
  '@bolt/runtime': {
    replacement: '',
    version: '',
    reason: 'Bolt-specific runtime',
  },
  '@v0/components': {
    replacement: 'shadcn/ui',
    version: 'latest',
    reason: 'V0-specific components',
  },
};

// Vérifier les dépendances d'un package.json
export const auditDependencies = (packageJson: {
  dependencies?: Record<string, string>;
  devDependencies?: Record<string, string>;
}): Array<{
  name: string;
  type: 'dependency' | 'devDependency';
  action: 'remove' | 'replace';
  replacement?: string;
  reason: string;
}> => {
  const issues: Array<{
    name: string;
    type: 'dependency' | 'devDependency';
    action: 'remove' | 'replace';
    replacement?: string;
    reason: string;
  }> = [];
  
  const checkDeps = (deps: Record<string, string> | undefined, type: 'dependency' | 'devDependency') => {
    if (!deps) return;
    
    for (const [name] of Object.entries(deps)) {
      const proprietary = PROPRIETARY_DEPS[name];
      if (proprietary) {
        issues.push({
          name,
          type,
          action: proprietary.replacement ? 'replace' : 'remove',
          replacement: proprietary.replacement || undefined,
          reason: proprietary.reason,
        });
      }
    }
  };
  
  checkDeps(packageJson.dependencies, 'dependency');
  checkDeps(packageJson.devDependencies, 'devDependency');
  
  return issues;
};

// Générer un package.json nettoyé
export const cleanPackageJson = (packageJson: Record<string, unknown>): Record<string, unknown> => {
  const cleaned = { ...packageJson };
  
  // Nettoyer les dépendances
  if (cleaned.dependencies && typeof cleaned.dependencies === 'object') {
    const deps = { ...(cleaned.dependencies as Record<string, string>) };
    for (const propDep of Object.keys(PROPRIETARY_DEPS)) {
      delete deps[propDep];
    }
    cleaned.dependencies = deps;
  }
  
  // Nettoyer les devDependencies
  if (cleaned.devDependencies && typeof cleaned.devDependencies === 'object') {
    const devDeps = { ...(cleaned.devDependencies as Record<string, string>) };
    for (const propDep of Object.keys(PROPRIETARY_DEPS)) {
      delete devDeps[propDep];
    }
    cleaned.devDependencies = devDeps;
  }
  
  // Supprimer les scripts spécifiques IDE
  if (cleaned.scripts && typeof cleaned.scripts === 'object') {
    const scripts = { ...(cleaned.scripts as Record<string, string>) };
    delete scripts['lovable:tag'];
    delete scripts['lovable:dev'];
    delete scripts['bolt:preview'];
    delete scripts['v0:preview'];
    cleaned.scripts = scripts;
  }
  
  return cleaned;
};
