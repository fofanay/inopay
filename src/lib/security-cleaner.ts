/**
 * INOPAY SECURITY CLEANER
 * Utilitaires pour nettoyer le code des signatures IDE et dépendances propriétaires
 * 
 * Ce module assure que le projet peut être déployé sans aucune trace
 * des plateformes de développement (Lovable, Bolt, V0, Cursor, etc.)
 */

// Patterns à supprimer des fichiers source
export const SIGNATURE_PATTERNS = {
  // Attributs data-lovable-* (toutes variations)
  dataLovableId: /\s*data-lovable-id="[^"]*"/gi,
  dataLovablePath: /\s*data-lovable-path="[^"]*"/gi,
  dataLovableComponent: /\s*data-lovable-component="[^"]*"/gi,
  dataLovableGeneric: /\s*data-lovable[^=]*="[^"]*"/gi,
  
  // Attributs data-* génériques de plateformes
  dataBoltId: /\s*data-bolt-id="[^"]*"/gi,
  dataV0Id: /\s*data-v0-id="[^"]*"/gi,
  dataCursorId: /\s*data-cursor-id="[^"]*"/gi,
  dataReplitId: /\s*data-replit-id="[^"]*"/gi,
  
  // Commentaires auto-générés par les IDEs
  lovableComment: /\/\*\s*@lovable[^*]*\*\//gi,
  lovableInlineComment: /\/\/\s*@lovable[^\n]*/gi,
  boltComment: /\/\*\s*@bolt[^*]*\*\//gi,
  boltInlineComment: /\/\/\s*@bolt[^\n]*/gi,
  v0Comment: /\/\*\s*@v0[^*]*\*\//gi,
  v0InlineComment: /\/\/\s*@v0[^\n]*/gi,
  cursorComment: /\/\*\s*@cursor[^*]*\*\//gi,
  cursorInlineComment: /\/\/\s*@cursor[^\n]*/gi,
  
  // Commentaires génériques d'auto-génération
  generatedComment: /\/\*\s*This file is automatically generated[^*]*\*\//gi,
  doNotEditComment: /\/\*\s*Do not edit it directly[^*]*\*\//gi,
  autoGeneratedComment: /\/\*\s*Auto-generated by[^*]*\*\//gi,
  
  // Imports spécifiques aux plateformes
  lovableTaggerImport: /import\s*{?\s*componentTagger\s*}?\s*from\s*["']lovable-tagger["'];?\n?/gi,
  lovableTaggerUsage: /componentTagger\(\),?\s*/gi,
  
  // Métadonnées dans les attributs HTML
  lovableSourceMap: /\/\*#\s*sourceMappingURL=[^*]*lovable[^*]*\*\//gi,
};

// Nettoyer le contenu d'un fichier
export const cleanFileContent = (content: string): string => {
  let cleaned = content;
  
  // Appliquer tous les patterns de nettoyage
  for (const pattern of Object.values(SIGNATURE_PATTERNS)) {
    cleaned = cleaned.replace(pattern, '');
  }
  
  // Nettoyer les lignes vides multiples
  cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
  
  // Nettoyer les espaces en fin de ligne
  cleaned = cleaned.replace(/[ \t]+$/gm, '');
  
  return cleaned;
};

// Liste des préfixes d'attributs à nettoyer
const PLATFORM_PREFIXES = [
  'data-lovable',
  'data-bolt',
  'data-v0',
  'data-cursor',
  'data-replit',
  'data-stackblitz',
];

// Nettoyer le DOM au runtime - supprime TOUTES les signatures de plateformes
export const cleanDOMSignatures = (): number => {
  let removedCount = 0;
  
  // Sélecteur pour tous les attributs de plateformes connues
  const selector = PLATFORM_PREFIXES.map(p => `[${p}-id], [${p}-path], [${p}-component]`).join(', ');
  const elements = document.querySelectorAll(selector);
  
  elements.forEach((element) => {
    Array.from(element.attributes).forEach((attr) => {
      // Supprimer tout attribut commençant par un préfixe de plateforme
      if (PLATFORM_PREFIXES.some(prefix => attr.name.startsWith(prefix))) {
        element.removeAttribute(attr.name);
        removedCount++;
      }
    });
  });
  
  // Nettoyer aussi les commentaires HTML qui pourraient contenir des infos de plateforme
  cleanHTMLComments();
  
  return removedCount;
};

// Nettoyer les commentaires HTML contenant des références aux plateformes
const cleanHTMLComments = (): void => {
  const walker = document.createTreeWalker(
    document.body,
    NodeFilter.SHOW_COMMENT,
    null
  );
  
  const commentsToRemove: Comment[] = [];
  let node: Comment | null;
  
  while ((node = walker.nextNode() as Comment | null)) {
    const content = node.textContent?.toLowerCase() || '';
    if (
      content.includes('lovable') ||
      content.includes('bolt') ||
      content.includes('v0.dev') ||
      content.includes('cursor') ||
      content.includes('auto-generated')
    ) {
      commentsToRemove.push(node);
    }
  }
  
  commentsToRemove.forEach(comment => comment.remove());
};

// Observer pour nettoyer les nouveaux éléments ajoutés au DOM
let cleanerObserver: MutationObserver | null = null;

export const startDOMCleaner = (): void => {
  if (cleanerObserver) return;
  
  cleanerObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.addedNodes.forEach((node) => {
        if (node instanceof HTMLElement) {
          cleanElementAndChildren(node);
        }
      });
    });
  });
  
  cleanerObserver.observe(document.body, {
    childList: true,
    subtree: true,
  });
};

// Nettoyer un élément et tous ses enfants
const cleanElementAndChildren = (element: HTMLElement): void => {
  // Nettoyer l'élément lui-même
  Array.from(element.attributes).forEach((attr) => {
    if (PLATFORM_PREFIXES.some(prefix => attr.name.startsWith(prefix))) {
      element.removeAttribute(attr.name);
    }
  });
  
  // Nettoyer tous les enfants
  const selector = PLATFORM_PREFIXES.map(p => `[${p}-id], [${p}-path], [${p}-component]`).join(', ');
  const children = element.querySelectorAll(selector);
  children.forEach((child) => {
    Array.from(child.attributes).forEach((attr) => {
      if (PLATFORM_PREFIXES.some(prefix => attr.name.startsWith(prefix))) {
        child.removeAttribute(attr.name);
      }
    });
  });
};

export const stopDOMCleaner = (): void => {
  if (cleanerObserver) {
    cleanerObserver.disconnect();
    cleanerObserver = null;
  }
};

// Dépendances propriétaires à remplacer
export const PROPRIETARY_DEPS: Record<string, { 
  replacement: string; 
  version: string;
  reason: string;
}> = {
  'lovable-tagger': {
    replacement: '',
    version: '',
    reason: 'IDE-specific, not needed in production',
  },
  '@lovable/ui': {
    replacement: '@radix-ui/react-*',
    version: 'latest',
    reason: 'Lovable-specific UI wrapper',
  },
  '@bolt/runtime': {
    replacement: '',
    version: '',
    reason: 'Bolt-specific runtime',
  },
  '@v0/components': {
    replacement: 'shadcn/ui',
    version: 'latest',
    reason: 'V0-specific components',
  },
};

// Vérifier les dépendances d'un package.json
export const auditDependencies = (packageJson: {
  dependencies?: Record<string, string>;
  devDependencies?: Record<string, string>;
}): Array<{
  name: string;
  type: 'dependency' | 'devDependency';
  action: 'remove' | 'replace';
  replacement?: string;
  reason: string;
}> => {
  const issues: Array<{
    name: string;
    type: 'dependency' | 'devDependency';
    action: 'remove' | 'replace';
    replacement?: string;
    reason: string;
  }> = [];
  
  const checkDeps = (deps: Record<string, string> | undefined, type: 'dependency' | 'devDependency') => {
    if (!deps) return;
    
    for (const [name] of Object.entries(deps)) {
      const proprietary = PROPRIETARY_DEPS[name];
      if (proprietary) {
        issues.push({
          name,
          type,
          action: proprietary.replacement ? 'replace' : 'remove',
          replacement: proprietary.replacement || undefined,
          reason: proprietary.reason,
        });
      }
    }
  };
  
  checkDeps(packageJson.dependencies, 'dependency');
  checkDeps(packageJson.devDependencies, 'devDependency');
  
  return issues;
};

// Générer un package.json nettoyé
export const cleanPackageJson = (packageJson: Record<string, unknown>): Record<string, unknown> => {
  const cleaned = { ...packageJson };
  
  // Nettoyer les dépendances
  if (cleaned.dependencies && typeof cleaned.dependencies === 'object') {
    const deps = { ...(cleaned.dependencies as Record<string, string>) };
    for (const propDep of Object.keys(PROPRIETARY_DEPS)) {
      delete deps[propDep];
    }
    cleaned.dependencies = deps;
  }
  
  // Nettoyer les devDependencies
  if (cleaned.devDependencies && typeof cleaned.devDependencies === 'object') {
    const devDeps = { ...(cleaned.devDependencies as Record<string, string>) };
    for (const propDep of Object.keys(PROPRIETARY_DEPS)) {
      delete devDeps[propDep];
    }
    cleaned.devDependencies = devDeps;
  }
  
  // Supprimer les scripts spécifiques IDE
  if (cleaned.scripts && typeof cleaned.scripts === 'object') {
    const scripts = { ...(cleaned.scripts as Record<string, string>) };
    delete scripts['lovable:tag'];
    delete scripts['lovable:dev'];
    delete scripts['bolt:preview'];
    delete scripts['v0:preview'];
    cleaned.scripts = scripts;
  }
  
  return cleaned;
};
